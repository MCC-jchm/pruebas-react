"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var React=require("react"),React__default=_interopDefault(React),reactDom=require("react-dom");function useCreateDomElement({tag:e,parentElement:t=document.body}){const[r,n]=React.useState(null);return React.useEffect(()=>{const r=document.createElement(e);return t.appendChild(r),n(r),()=>{t.removeChild(r)}},[e,t]),r}function Layer({children:e,parentElement:t=document.body}){const r=useCreateDomElement({tag:"div",parentElement:t});return r?React.createElement(React.Fragment,null,reactDom.createPortal(e,r)):null}function isChildOf(e,t){if(e===t)return!0;if(e.children&&e.children.length>0)for(let r=0;r<e.children.length;r++){const n=e.children[r];if(n&&isChildOf(n,t))return!0}return!1}function useOutsideClick(e,t){React__default.useEffect(()=>{function r(r){for(const t of e)if(t.current&&isChildOf(t.current,r.target))return;t()}return document.addEventListener("click",r),document.addEventListener("touchstart",r),()=>{document.removeEventListener("click",r),document.removeEventListener("touchstart",r)}})}function useOnScroll(e,t,r=!0){React.useEffect(()=>{if(!r)return;const n=t;return[...e,window].forEach(e=>{e.addEventListener("scroll",n)}),()=>{[...e,window].forEach(e=>{e.removeEventListener("scroll",n)})}},[t,e,r])}function useElementRef(e,t){const[r,n]=React.useState(e||null),o=React.useRef(null);return[React.useCallback(e=>{e&&e!==o.current&&(o.current=e,n(t?t(e):e))},[]),r]}function useOnWindowResize(e,t=!0){React.useEffect(()=>{if(!t)return;const r=e;return window.addEventListener("resize",r),()=>{window.removeEventListener("resize",r)}},[e,t])}function safeWindow(e,t){return"undefined"==typeof window?t:e(window)}const useIsomorphicLayoutEffect="undefined"!=typeof window?React.useLayoutEffect:React.useEffect;function useTrackElementResize(e,t,r,n,o){const i=React.useRef(o);i.current=o;const c=e||safeWindow(e=>e.ResizeObserver,class{});if(!c)throw new Error("This browser does not support `ResizeObserver` out of the box. Please provide a polyfill as a prop.");const s=React.useRef(new c(()=>{t.current&&i.current()}));return useIsomorphicLayoutEffect(()=>{n?r&&s.current.observe(r):(r&&s.current.unobserve(r),t.current&&s.current.unobserve(t.current))},[n,r]),React.useEffect(()=>()=>{s.current.disconnect()},[]),s.current}function compensateScrollbars(e,t,r){const n=e.width-t,o=e.height-r;return{left:e.left,top:e.top,width:e.width-n,right:e.right-n,height:e.height-o,bottom:e.bottom-o}}function findScrollContainers(e){const t=[];if(!e.parentElement)return t;if(e===document.body)return t;const r=e.parentElement,{overflow:n,overflowX:o,overflowY:i}=window.getComputedStyle(r);return[n,o,i].some(e=>"auto"===e||"scroll"===e)&&t.push(r),[...t,...findScrollContainers(r)]}const EMPTY_STYLE={};function isSet(e){return void 0!==e&&null!==e}function areStylesTheSame(e,t){const r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;for(let o=0;o<Math.max(r.length,n.length);o++){const i=r[o]||n[o];if(e[i]!==t[i])return!1}return!0}function shouldUpdateStyles(e,t){return!areStylesTheSame(e.layer,t.layer)||!areStylesTheSame(e.arrow,t.arrow)}function getWindowClientRect(){return{top:0,left:0,right:window.innerWidth,bottom:window.innerHeight,height:window.innerHeight,width:window.innerWidth}}const convertFloat=e=>parseFloat(e.replace("px",""));function getContentBox(e){const{width:t,height:r,boxSizing:n,borderLeft:o,borderRight:i,borderTop:c,borderBottom:s,paddingLeft:l,paddingRight:a,paddingTop:f,paddingBottom:u}=window.getComputedStyle(e);return{width:"border-box"===n?convertFloat(t):[t,o,i,l,a].reduce((e,t)=>e+(t?convertFloat(t):0),0),height:"border-box"===n?convertFloat(r):[r,c,s,f,u].reduce((e,t)=>e+(t?convertFloat(t):0),0)}}const Anchor={BOTTOM_LEFT:"BOTTOM_LEFT",BOTTOM_RIGHT:"BOTTOM_RIGHT",BOTTOM_CENTER:"BOTTOM_CENTER",TOP_LEFT:"TOP_LEFT",TOP_CENTER:"TOP_CENTER",TOP_RIGHT:"TOP_RIGHT",LEFT_BOTTOM:"LEFT_BOTTOM",LEFT_CENTER:"LEFT_CENTER",LEFT_TOP:"LEFT_TOP",RIGHT_BOTTOM:"RIGHT_BOTTOM",RIGHT_CENTER:"RIGHT_CENTER",RIGHT_TOP:"RIGHT_TOP"},POSSIBLE_ANCHORS=Object.keys(Anchor);function getPrimaryDirection(e){return e.startsWith("TOP_")||e.startsWith("BOTTOM_")?"Y":"X"}function primaryIsY(e){return"TOP"===e||"BOTTOM"===e}function getPrimaryByIndex(e,t,r,n){const o=primaryIsY(t);return e<3?t:e<6?o?r:n:e<9?o?["LEFT","RIGHT"].filter(e=>e!==r)[0]:["TOP","BOTTOM"].filter(e=>e!==n)[0]:o?["TOP","BOTTOM"].filter(e=>e!==t)[0]:["LEFT","RIGHT"].filter(e=>e!==t)[0]}function getSecondaryByIndex(e,t,r){const n=primaryIsY(t);switch(e){case 9:case 0:return r;case 1:case 10:return"CENTER"===r?n?"RIGHT":"BOTTOM":"CENTER";case 4:case 7:return"CENTER";case 2:case 11:return n?["LEFT","RIGHT"].filter(e=>e!==r)[0]:["TOP","BOTTOM"].filter(e=>e!==r)[0];case 3:case 6:return n?"BOTTOM"===t?"TOP":"BOTTOM":"LEFT"===t?"RIGHT":"LEFT";case 5:case 8:return n?"BOTTOM"===t?"BOTTOM":"TOP":"LEFT"===t?"LEFT":"RIGHT"}return"LEFT"}function getSecondaryAnchorOptionsByPrimary(e,t){return t.filter(t=>t.startsWith(e))}function splitAnchor(e){const[t,r]=e.split("_");return{primary:t,secondary:r}}function getLayerSideByAnchor(e){return"CENTER"===e?"center":splitAnchor(e).primary.toLowerCase()}function getAnchorPriority(e,t,r,n){const{primary:o,secondary:i}="CENTER"!==e?splitAnchor(e):{primary:n,secondary:"CENTER"};let c=POSSIBLE_ANCHORS.map((e,t)=>`${getPrimaryByIndex(t,o,r,n)}_${getSecondaryByIndex(t,o,i)}`).filter(e=>t.indexOf(e)>-1);return-1===c.indexOf(e)&&(c=[e,...c]),c}const primaryStyleGetters={BOTTOM:({rects:e,scrollTop:t,triggerOffset:r})=>{const{trigger:n,relativeParent:o}=e;return{top:n.top+n.height-(o.top-t)+r}},TOP:({rects:e,scrollTop:t,triggerOffset:r})=>{const{trigger:n,relativeParent:o,layer:i}=e;return{top:n.top-i.height-(o.top-t)-r}},LEFT:({rects:e,scrollLeft:t,triggerOffset:r})=>{const{trigger:n,relativeParent:o,layer:i}=e;return{left:n.left-i.width-(o.left-t)-r}},RIGHT:({rects:e,scrollLeft:t,triggerOffset:r})=>{const{trigger:n,relativeParent:o}=e;return{left:n.left-o.left+t+n.width+r}}},secondaryStyleGetters={TOP:({rects:e,scrollTop:t,offsetSecondary:r})=>{const{trigger:n,relativeParent:o}=e;return{top:n.top-o.top+t+r}},BOTTOM:({rects:e,scrollTop:t,offsetSecondary:r})=>{const{trigger:n,relativeParent:o,layer:i}=e;return{top:n.bottom-i.height-(o.top-t)-r}},CENTER:({rects:e,scrollTop:t,scrollLeft:r,primaryDirection:n,offsetSecondary:o})=>{const{trigger:i,relativeParent:c,layer:s}=e;return"Y"===n?{left:i.left-c.left+r+i.width/2-s.width/2-o}:{top:i.top-c.top+t+i.height/2-s.height/2+o}},LEFT:({rects:e,scrollLeft:t,offsetSecondary:r})=>{const{trigger:n,relativeParent:o}=e;return{left:n.left-o.left+t+r}},RIGHT:({rects:e,scrollLeft:t,offsetSecondary:r})=>{const{trigger:n,relativeParent:o,layer:i}=e;return{left:n.right-i.width-(o.left-t)-r}}},centerGetter=({rects:e,scrollTop:t,scrollLeft:r})=>{const{trigger:n,relativeParent:o,layer:i}=e,c=n.left-o.left+r+n.width/2-i.width/2;return{top:n.top-o.top+t+n.height/2-i.height/2,left:c}};function getAbsolutePositions({anchor:e,rects:t,triggerOffset:r,offsetSecondary:n,scrollLeft:o,scrollTop:i}){if("CENTER"===e)return centerGetter({rects:t,triggerOffset:r,offsetSecondary:n,scrollLeft:o,scrollTop:i,primaryDirection:"Y"});const{primary:c,secondary:s}=splitAnchor(e),l=getPrimaryDirection(e),a=primaryStyleGetters[c]({rects:t,triggerOffset:r,offsetSecondary:n,scrollLeft:o,scrollTop:i,primaryDirection:l}),f=secondaryStyleGetters[s]({rects:t,triggerOffset:r,offsetSecondary:n,scrollLeft:o,scrollTop:i,primaryDirection:l});return{...a,...f}}function fixLayerDimensions(e,t,r){const n="function"==typeof r?r(getLayerSideByAnchor(t)):r;return{top:e.top,left:e.left,right:e.right,bottom:e.bottom,width:n.width,height:n.height}}const primaryLayerRectGetters={TOP:({trigger:e,layer:t,triggerOffset:r})=>{const n=e.top-r;return{bottom:n,top:n-t.height}},BOTTOM:({trigger:e,layer:t,triggerOffset:r})=>{const n=e.bottom+r;return{top:n,bottom:n+t.height}},LEFT:({trigger:e,layer:t,triggerOffset:r})=>{const n=e.left-r;return{right:n,left:n-t.width}},RIGHT:({trigger:e,layer:t,triggerOffset:r})=>{const n=e.right+r;return{left:n,right:n+t.width}}},secondaryLayerRectGetters={TOP:({trigger:e,layer:t,offsetSecondary:r})=>{const n=e.top+r;return{top:n,bottom:n+t.height}},BOTTOM:({trigger:e,layer:t,offsetSecondary:r})=>{const n=e.bottom-r;return{bottom:n,top:n-t.height}},LEFT:({trigger:e,layer:t,offsetSecondary:r})=>{const n=e.left+r;return{left:n,right:n+t.width}},RIGHT:({trigger:e,layer:t,offsetSecondary:r})=>{const n=e.right-r;return{right:n,left:n-t.width}},CENTER:({trigger:e,layer:t,primaryDirection:r,offsetSecondary:n})=>{if("Y"===r){const r=e.left+e.width/2-t.width/2-n;return{left:r,right:r+t.width}}const o=e.top+e.height/2-t.height/2+n;return{top:o,bottom:o+t.height}}};function getLayerRectByAnchor({trigger:e,layer:t,anchor:r,triggerOffset:n,scrollOffset:o=0,offsetSecondary:i=0,layerDimensions:c}){let s,l;const a=c?fixLayerDimensions(t,r,c):t;if("CENTER"===r)s=secondaryLayerRectGetters.CENTER({trigger:e,layer:a,primaryDirection:"Y",triggerOffset:n,offsetSecondary:i}),l=secondaryLayerRectGetters.CENTER({trigger:e,layer:a,primaryDirection:"X",triggerOffset:n,offsetSecondary:i});else{const{primary:t,secondary:o}=splitAnchor(r),c=getPrimaryDirection(r);s=primaryLayerRectGetters[t]({trigger:e,layer:a,primaryDirection:c,triggerOffset:n,offsetSecondary:i}),l=secondaryLayerRectGetters[o]({trigger:e,layer:a,primaryDirection:c,triggerOffset:n,offsetSecondary:i})}const f={...t,...s,...l,width:a.width,height:a.height};return f.top=f.top-o,f.right=f.right+o,f.left=f.left-o,f.bottom=f.bottom+o,f}const ALL_OFFSET_SIDES=["bottom","top","left","right"];function getLayerOffsetsToParent(e,t){return{top:e.top-t.top,bottom:t.bottom-e.bottom,left:e.left-t.left,right:t.right-e.right}}function getLayerOffsetsToParents(e,t){return t.map(t=>getLayerOffsetsToParent(e,t))}function isLayerCompletelyInvisible(e,t){return t.some(t=>e.bottom<=t.top||e.right<=t.left||e.top>=t.bottom||e.left>=t.right)}function doesEntireLayerFitWithinScrollParents(e,t){return getLayerOffsetsToParents(e,t).every(e=>ALL_OFFSET_SIDES.every(t=>e[t]>=0))}function reduceOffsets(e){const t=e.reduce((e,t)=>(ALL_OFFSET_SIDES.forEach(r=>{e[r]=[...e[r],t[r]]}),e),{top:[],bottom:[],left:[],right:[]});return ALL_OFFSET_SIDES.reduce((e,r)=>(e[r]=t[r].sort((e,t)=>e-t)[0],e),{})}function getNegativeOffsetSides(e){const t=reduceOffsets(e);return ALL_OFFSET_SIDES.filter(e=>t[e]<0)}function getVisibleLayerSurface(e,t){const r=getLayerOffsetsToParent(e,t),n=ALL_OFFSET_SIDES.filter(e=>r[e]<0).reduce((e,t)=>{const n="top"===t||"bottom"===t?"height":"width";return{...e,[n]:e[n]+r[t]}},e);return n.width*n.height}function getVisibleLayerSurfaceWithinScrollParent(e,t){return t.map(t=>getVisibleLayerSurface(e,t)).sort((e,t)=>e-t)[0]}function doesAnchorFitWithinScrollParents(e,t,r,n,o){return doesEntireLayerFitWithinScrollParents(getLayerRectByAnchor({anchor:e,trigger:t.trigger,layer:t.layer,triggerOffset:r,scrollOffset:n,layerDimensions:o}),t.scrollParents)}function getLayerOffsetsToScrollParentsByAnchor(e,t,r,n){return getLayerOffsetsToParents(getLayerRectByAnchor({anchor:e,trigger:t.trigger,layer:t.layer,triggerOffset:r,scrollOffset:n}),t.scrollParents)}function getOffsetSurface(e,t,r,n){const o=getPrimaryDirection(e);return(t["X"===o?"width":"height"]-r-2*n)*(t["X"===o?"height":"width"]-r-2*n)}function findAnchorByLayerSurface(e,t,r,n,o){return t.map(t=>{const i=getLayerRectByAnchor({anchor:t,layer:e.layer,trigger:e.trigger,scrollOffset:n,triggerOffset:r,layerDimensions:o});return{anchor:t,square:getVisibleLayerSurfaceWithinScrollParent(i,e.scrollParents)-getOffsetSurface(t,i,r,n)}}).sort((e,t)=>t.square-e.square)[0].anchor}function findBestSuitableAnchor(e,t,r,n,o){const i=t.find(t=>doesAnchorFitWithinScrollParents(t,e,r,n,o));return i||findAnchorByLayerSurface(e,t,r,n,o)}function getSecondaryOffsetSide(e,t,r,n,o){const i=getPrimaryDirection(e);return getNegativeOffsetSides(getLayerOffsetsToScrollParentsByAnchor(t,r,n,o)).find(e=>"X"===i?"top"===e||"bottom"===e:"left"===e||"right"===e)}function findSecondaryOffset(e,t,r,n,o){const{primary:i}=splitAnchor(e),c=getSecondaryAnchorOptionsByPrimary(i,t);if(1===c.length)return 0;const s=0===c.indexOf(e),l=doesAnchorFitWithinScrollParents(e,r,n,o);if(s&&l)return 0;const a=getSecondaryOffsetSide(e,c.find(e=>!doesAnchorFitWithinScrollParents(e,r,n,o)),r,n,o);if(!a)return 0;const f=reduceOffsets(getLayerOffsetsToScrollParentsByAnchor(e,r,n,o));let u=Math.min(-f[a],0);return!e.includes("_CENTER")||"bottom"!==a&&"left"!==a||(u=-u),u}function getArrowStyle(e,t,r){return"bottom"===r?{bottom:"100%",top:null,left:t.left+t.width/2-e.left,right:null}:"right"===r?{right:"100%",left:null,top:t.top+t.height/2-e.top,bottom:null}:"top"===r?{top:"100%",bottom:null,left:t.left+t.width/2-e.left,right:null}:{left:"100%",right:null,top:t.top+t.height/2-e.top,bottom:null}}function getAbsoluteStyle({rects:e,scrollTop:t,scrollLeft:r,triggerOffset:n,scrollOffset:o,possibleAnchors:i,preferedAnchor:c,preferedX:s,preferedY:l,autoAdjust:a,snapToAnchor:f,layerDimensions:u}){const g=getAnchorPriority(c,i,s,l),h=a?findBestSuitableAnchor(e,g,n,o,u):c,d=a&&!f&&"CENTER"!==h?findSecondaryOffset(h,g,e,n,o):0,y=getAbsolutePositions({anchor:h,rects:e,triggerOffset:n,offsetSecondary:d,scrollLeft:r,scrollTop:t}),p=getLayerRectByAnchor({anchor:h,trigger:e.trigger,layer:e.layer,triggerOffset:n,offsetSecondary:d,layerDimensions:u});return u&&(y.width=p.width,y.height=p.height),{layerStyle:y,layerRect:p,anchor:h}}function ToggleLayer({children:e,renderLayer:t,placement:r,onStyle:n,isOpen:o,closeOnOutsideClick:i,onOutsideClick:c,onDisappear:s,closeOnDisappear:l,fixed:a,container:f,...u}){const[g,{relativeParentElement:h,triggerElement:d,scrollParents:y}]=useElementRef({triggerElement:null,relativeParentElement:null,scrollParents:[]},React.useCallback(e=>{const t=findScrollContainers(e),r=t[0]||document.body;if(r===document.body)document.body.style.position="relative";else if("development"===process.env.NODE_ENV){const e="function"==typeof f?f():f,t=window.getComputedStyle(r).position;"relative"!==t&&"absolute"!==t&&"fixed"!==t&&!a&&!e&&console.warn(`react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'fixed' prop to true. This is needed in order to position the layers properly. Currently the scroll-container is positioned: "${t}". Visit https://react-laag.com/docs/#position-relative for more info.`,r)}return{triggerElement:e,relativeParentElement:r,scrollParents:t}},[])),[p]=React.useState({layer:EMPTY_STYLE,arrow:EMPTY_STYLE,layerSide:r.anchor.split("_")[0].toLowerCase()}),[T,O]=React.useState(p),m=React.useRef(T),E=React.useRef(null),[S,R]=React.useState(!1),L=isSet(o)?o:S,w=React.useCallback(()=>{const e=d.getBoundingClientRect();if(0===e.height)return;if(!E.current)return;const t=a?[getWindowClientRect()]:[...y.map(e=>compensateScrollbars(e.getBoundingClientRect(),e.clientWidth,e.clientHeight)),getWindowClientRect()],i={autoAdjust:r.autoAdjust||!1,snapToAnchor:r.snapToAnchor||!1,triggerOffset:r.triggerOffset||0,scrollOffset:r.scrollOffset||0,possibleAnchors:r.possibleAnchors||POSSIBLE_ANCHORS,preferedAnchor:r.anchor,preferedX:r.preferX||"RIGHT",preferedY:r.preferY||"BOTTOM",scrollLeft:h===document.body?0:h.scrollLeft,scrollTop:h===document.body?0:h.scrollTop,relativeParentElement:h,layerDimensions:r.layerDimensions},c=E.current.getBoundingClientRect(),f={layer:{top:c.top,left:c.left,right:c.right,bottom:c.bottom,...getContentBox(E.current)},relativeParent:h.getBoundingClientRect(),scrollParents:t,trigger:e},{layerRect:u,layerStyle:g,anchor:p}=getAbsoluteStyle({rects:f,...i});a&&(g.top=u.top,g.left=u.left);const T=getLayerSideByAnchor(p),S={layer:g,arrow:"CENTER"===p?EMPTY_STYLE:getArrowStyle(u,e,T),layerSide:T};shouldUpdateStyles(m.current,S)&&(isSet(n)?(m.current=S,n(S.layer,S.arrow,T)):O(S));const L=isSet(s),w=l&&!isSet(o);if(L||w){const t=[...y.map(e=>e.getBoundingClientRect()),getWindowClientRect()],r=!doesEntireLayerFitWithinScrollParents(a?e:u,t),n=isLayerCompletelyInvisible(a?e:u,t);L?s(n?"full":"partial"):("partial"===l&&r&&R(!1),"full"===l&&n&&R(!1))}},[h,L,d,y,a,r]),b=useTrackElementResize(u.ResizeObserver,E,d,L,w);useIsomorphicLayoutEffect(()=>{const e=!isSet(n);T!==m.current&&e?m.current=T:L?w():m.current=p}),useOnWindowResize(w,L),useOnScroll(y,w,L),useOutsideClick([{current:d},E],React.useCallback(()=>{L&&(c&&c(),i&&!isSet(o)&&R(!1))},[L,R,o]));const P="function"==typeof f?f():f;return React.createElement(React.Fragment,null,React.createElement(React.Fragment,null,e({isOpen:L,close:()=>{if(isSet(o))throw new Error("You cannot call `close()` while using the `isOpen` prop");R(!1)},open:()=>{if(isSet(o))throw new Error("You cannot call `open()` while using the `isOpen` prop");R(!0)},toggle:()=>{if(isSet(o))throw new Error("You cannot call `toggle()` while using the `isOpen` prop");R(!S)},triggerRef:g,layerSide:L?T.layerSide:null}),h&&React.createElement(Layer,{parentElement:P||h},t({layerProps:{ref:e=>{e&&b.observe(e),E.current=e},style:{...isSet(n)?EMPTY_STYLE:T.layer,position:a?"fixed":"absolute",willChange:"top, bottom, left, right, width, height"}},arrowStyle:{...isSet(n)?EMPTY_STYLE:T.arrow,position:"absolute",willChange:"top, bottom, left, right"},isOpen:L,layerSide:T.layerSide,triggerRect:d?d.getBoundingClientRect():null,close:()=>{if(isSet(o))throw new Error("You cannot call `close()` while using the `isOpen` prop");R(!1)}}))))}function useHover({delayEnter:e=0,delayLeave:t=0}){const[r,n]=React.useState(!1),o=React.useRef(null),i=React.useRef(null);return React.useEffect(()=>{const e=o.current;function t(){r&&(o.current&&(clearTimeout(o.current),o.current=null),n(!1))}return window.addEventListener("scroll",t,!0),()=>{window.removeEventListener("scroll",t),e&&clearTimeout(e)}},[r]),[r,{onMouseEnter:function(){"leaving"===i.current&&o.current&&(clearTimeout(o.current),o.current=null,i.current=null),r||(i.current="entering",o.current=setTimeout(()=>{n(!0),o.current=null,i.current=null},e))},onMouseLeave:function(){"entering"===i.current&&o.current&&(clearTimeout(o.current),o.current=null),r&&(i.current="leaving",o.current=setTimeout(()=>{n(!1),o.current=null},t))}}]}exports.ToggleLayer=ToggleLayer,exports.useHover=useHover,exports.anchor=Anchor;