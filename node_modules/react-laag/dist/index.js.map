{"version":3,"file":"index.js","sources":["../src/useCreateDomElement.tsx","../src/Layer.tsx","../src/useOutsideClick.tsx","../src/useOnScroll.tsx","../src/useElementRef.tsx","../src/useOnWindowResize.tsx","../src/domApi.ts","../src/useIsomorphicLayoutEffect.tsx","../src/useTrackElementResize.tsx","../src/compensateScrollbars.tsx","../src/findScrollContainers.tsx","../src/util.tsx","../src/anchor.tsx","../src/style/getAbsolutePositions.tsx","../src/rect/getLayerRectByAnchor.tsx","../src/rect/index.tsx","../src/style/getSuitableAnchor.tsx","../src/style/getSecondaryOffset.tsx","../src/style/getArrowStyle.tsx","../src/style/index.tsx","../src/ToggleLayer.tsx","../src/useHover.tsx"],"sourcesContent":["import * as React from \"react\";\n\ntype Props<T> = {\n  tag: T;\n  parentElement?: HTMLElement;\n};\n\n// created a new dom element and attaches it to the parent element\nfunction useCreateDomElement<T extends keyof ElementTagNameMap>({\n  tag,\n  parentElement = document.body\n}: Props<T>) {\n  const [domElement, setDomElement] = React.useState<\n    null | ElementTagNameMap[T]\n  >(null);\n\n  React.useEffect(() => {\n    const element = document.createElement(tag);\n\n    parentElement.appendChild(element);\n    setDomElement(element as any);\n\n    return () => {\n      parentElement.removeChild(element);\n    };\n  }, [tag, parentElement]);\n\n  return domElement;\n}\n\nexport default useCreateDomElement;\n","import * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\nimport useCreateDomElement from \"./useCreateDomElement\";\n\ntype Props = {\n  children: React.ReactNode;\n  parentElement?: HTMLElement;\n};\n\nfunction Layer({ children, parentElement = document.body }: Props) {\n  const element = useCreateDomElement({\n    tag: \"div\",\n    parentElement\n  });\n\n  if (!element) {\n    return null;\n  }\n\n  return <>{createPortal(children, element)}</>;\n}\n\nexport default Layer;\n","import React from \"react\";\n\nfunction isChildOf(parent: HTMLElement, target: HTMLElement) {\n  if (parent === target) {\n    return true;\n  }\n\n  const hasChildren = parent.children && parent.children.length > 0;\n\n  if (hasChildren) {\n    // tslint:disable-next-line\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      if (child && isChildOf(child as HTMLElement, target)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction useOutsideClick(\n  refs: Array<React.RefObject<HTMLElement | null | undefined>>,\n  callback: () => void\n) {\n  React.useEffect(() => {\n    function onClick(evt: any) {\n      for (const ref of refs) {\n        if (!ref.current) {\n          continue;\n        }\n\n        if (isChildOf(ref.current, evt.target as HTMLElement)) {\n          return;\n        }\n      }\n\n      callback();\n    }\n\n    document.addEventListener(\"click\", onClick);\n    document.addEventListener(\"touchstart\", onClick);\n\n    return () => {\n      document.removeEventListener(\"click\", onClick);\n      document.removeEventListener(\"touchstart\", onClick);\n    };\n  });\n}\n\nexport default useOutsideClick;\n","import * as React from \"react\";\n\nfunction useOnScroll(\n  elements: HTMLElement[],\n  onScroll: (event: UIEvent) => void,\n  trackScroll = true\n) {\n  React.useEffect(() => {\n    if (!trackScroll) {\n      return;\n    }\n\n    const handleScroll: any = onScroll;\n\n    [...elements, window].forEach(el => {\n      el.addEventListener(\"scroll\", handleScroll);\n    });\n\n    return () => {\n      [...elements, window].forEach(el => {\n        el.removeEventListener(\"scroll\", handleScroll);\n      });\n    };\n  }, [onScroll, elements, trackScroll]);\n}\n\nexport default useOnScroll;\n","import * as React from \"react\";\n\n/**\n * Tracks an element and keeps it in state\n * (together with other relevant state that depends on the element)\n */\nfunction useElementRef<T = HTMLElement | null>(\n  initialState?: T,\n  elementToState?: (element: HTMLElement) => T\n) {\n  const [state, setState] = React.useState<T | null>(initialState || null);\n\n  const lastElement = React.useRef<HTMLElement | null>(null);\n\n  const setRef = React.useCallback(node => {\n    if (node && node !== lastElement.current) {\n      lastElement.current = node;\n      if (elementToState) {\n        setState(elementToState(node));\n      } else {\n        setState(node);\n      }\n    }\n  }, []);\n\n  return [setRef, state] as [any, T];\n}\n\nexport default useElementRef;\n","import * as React from \"react\";\n\nfunction useOnWindowResize(\n  onResize: (event: FocusEvent) => void,\n  trackResize = true\n) {\n  React.useEffect(() => {\n    if (!trackResize) {\n      return;\n    }\n\n    const handleResize: any = onResize;\n\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n    };\n  }, [onResize, trackResize]);\n}\n\nexport default useOnWindowResize;\n","export function safeWindow<A, B>(getter: (window: Window) => A, fallback: B) {\n  if (typeof window === \"undefined\") {\n    return fallback;\n  }\n\n  return getter(window);\n}\n","import * as React from \"react\";\nconst useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n\nexport default useIsomorphicLayoutEffect;\n","import * as React from \"react\";\nimport { safeWindow } from \"./domApi\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\n\nexport default function useTrackElementResize(\n  injectedResizeObserver: any,\n  layerRef: React.RefObject<HTMLElement>,\n  triggerElement: HTMLElement | null,\n  isOpen: boolean,\n  callback: () => void\n) {\n  const callbackRef = React.useRef(callback);\n  callbackRef.current = callback;\n\n  const ResizeObserver =\n    injectedResizeObserver ||\n    safeWindow((window: any) => window.ResizeObserver, class ResizeObserver {});\n\n  if (!ResizeObserver) {\n    throw new Error(\n      \"This browser does not support `ResizeObserver` out of the box. Please provide a polyfill as a prop.\"\n    );\n  }\n\n  const resizeObserver = React.useRef(\n    new ResizeObserver(() => {\n      if (layerRef.current) {\n        callbackRef.current();\n      }\n    })\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      if (triggerElement) {\n        resizeObserver.current.observe(triggerElement);\n      }\n    } else {\n      if (triggerElement) {\n        resizeObserver.current.unobserve(triggerElement);\n      }\n      if (layerRef.current) {\n        resizeObserver.current.unobserve(layerRef.current);\n      }\n    }\n  }, [isOpen, triggerElement]);\n\n  React.useEffect(() => {\n    return () => {\n      resizeObserver.current.disconnect();\n    };\n  }, []);\n\n  return resizeObserver.current;\n}\n","export default function compensateScrollbars(\n  rect: ClientRect,\n  clientWidth: number,\n  clientHeight: number\n) {\n  const scrollbarWidth = rect.width - clientWidth;\n  const scrollbarHeight = rect.height - clientHeight;\n\n  return {\n    left: rect.left,\n    top: rect.top,\n    width: rect.width - scrollbarWidth,\n    right: rect.right - scrollbarWidth,\n    height: rect.height - scrollbarHeight,\n    bottom: rect.bottom - scrollbarHeight\n  };\n}\n","export default function findScrollContainers(\n  element: HTMLElement\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  /* istanbul ignore if */\n  if (!element.parentElement) {\n    return result;\n  }\n\n  if (element === document.body) {\n    return result;\n  }\n\n  const parent = element.parentElement;\n\n  const { overflow, overflowX, overflowY } = window.getComputedStyle(parent);\n\n  if (\n    [overflow, overflowX, overflowY].some(\n      prop => prop === \"auto\" || prop === \"scroll\"\n    )\n  ) {\n    result.push(parent);\n  }\n\n  return [...result, ...findScrollContainers(parent)];\n}\n","import { ResultingStyles } from \"./ToggleLayer\";\n\nexport const EMPTY_STYLE: React.CSSProperties = {};\n\nexport function isSet<T>(value: T) {\n  return value !== undefined && value !== null;\n}\n\nfunction areStylesTheSame(a: React.CSSProperties, b: React.CSSProperties) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < Math.max(aKeys.length, bKeys.length); i++) {\n    const key: keyof React.CSSProperties = aKeys[i] || (bKeys[i] as any);\n\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function shouldUpdateStyles(\n  prev: ResultingStyles,\n  next: ResultingStyles\n) {\n  if (\n    areStylesTheSame(prev.layer, next.layer) &&\n    areStylesTheSame(prev.arrow, next.arrow)\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function getWindowClientRect(): ClientRect {\n  return {\n    top: 0,\n    left: 0,\n    right: window.innerWidth,\n    bottom: window.innerHeight,\n    height: window.innerHeight,\n    width: window.innerWidth\n  };\n}\n\nconst convertFloat = (value: string) => parseFloat(value.replace(\"px\", \"\"));\n\nexport function getContentBox(element: HTMLElement) {\n  const {\n    width,\n    height,\n    boxSizing,\n    borderLeft,\n    borderRight,\n    borderTop,\n    borderBottom,\n    paddingLeft,\n    paddingRight,\n    paddingTop,\n    paddingBottom\n  } = window.getComputedStyle(element);\n\n  return {\n    width:\n      boxSizing === \"border-box\"\n        ? convertFloat(width!)\n        : [width, borderLeft, borderRight, paddingLeft, paddingRight].reduce(\n            (total, value) => total + (value ? convertFloat(value!) : 0),\n            0\n          ),\n    height:\n      boxSizing === \"border-box\"\n        ? convertFloat(height!)\n        : [height, borderTop, borderBottom, paddingTop, paddingBottom].reduce(\n            (total, value) => total + (value ? convertFloat(value!) : 0),\n            0\n          )\n  };\n}\n","import { AnchorEnum, Direction, Primary, Side, LayerSide } from \"./types\";\n\nexport const Anchor: Record<Exclude<AnchorEnum, \"CENTER\">, AnchorEnum> = {\n  BOTTOM_LEFT: \"BOTTOM_LEFT\",\n  BOTTOM_RIGHT: \"BOTTOM_RIGHT\",\n  BOTTOM_CENTER: \"BOTTOM_CENTER\",\n  TOP_LEFT: \"TOP_LEFT\",\n  TOP_CENTER: \"TOP_CENTER\",\n  TOP_RIGHT: \"TOP_RIGHT\",\n  LEFT_BOTTOM: \"LEFT_BOTTOM\",\n  LEFT_CENTER: \"LEFT_CENTER\",\n  LEFT_TOP: \"LEFT_TOP\",\n  RIGHT_BOTTOM: \"RIGHT_BOTTOM\",\n  RIGHT_CENTER: \"RIGHT_CENTER\",\n  RIGHT_TOP: \"RIGHT_TOP\"\n};\n\nexport const POSSIBLE_ANCHORS = Object.keys(Anchor) as AnchorEnum[];\n\nexport const PRIMARY_OPPOSITES: Record<Primary, Primary> = {\n  TOP: \"BOTTOM\",\n  BOTTOM: \"TOP\",\n  LEFT: \"RIGHT\",\n  RIGHT: \"LEFT\"\n};\n\nexport function getPrimaryDirection(anchor: AnchorEnum): Direction {\n  return anchor.startsWith(\"TOP_\") || anchor.startsWith(\"BOTTOM_\") ? \"Y\" : \"X\";\n}\n\nfunction primaryIsY(primary: Primary) {\n  return primary === \"TOP\" || primary === \"BOTTOM\";\n}\n\nfunction getPrimaryByIndex(\n  index: number,\n  preferedPrimary: Primary,\n  preferedX: \"LEFT\" | \"RIGHT\",\n  preferedY: \"TOP\" | \"BOTTOM\"\n): Primary {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n\n  if (index < 3) {\n    return preferedPrimary;\n  }\n  if (index < 6) {\n    return prefferedIsY ? preferedX : preferedY;\n  }\n  if (index < 9) {\n    if (prefferedIsY) {\n      return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedX)[0] as Primary;\n    } else {\n      return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedY)[0] as Primary;\n    }\n  }\n\n  if (prefferedIsY) {\n    return [\"TOP\", \"BOTTOM\"].filter(x => x !== preferedPrimary)[0] as Primary;\n  } else {\n    return [\"LEFT\", \"RIGHT\"].filter(x => x !== preferedPrimary)[0] as Primary;\n  }\n}\n\nfunction getSecondaryByIndex(\n  index: number,\n  preferedPrimary: Primary,\n  preferedSecondary: Side\n): Side {\n  const prefferedIsY = primaryIsY(preferedPrimary);\n\n  switch (index) {\n    case 9:\n    case 0:\n      return preferedSecondary;\n\n    case 1:\n    case 10: {\n      if (preferedSecondary === \"CENTER\") {\n        return prefferedIsY ? \"RIGHT\" : \"BOTTOM\";\n      }\n\n      return \"CENTER\";\n    }\n\n    case 4:\n    case 7:\n      return \"CENTER\";\n\n    case 2:\n    case 11: {\n      if (prefferedIsY) {\n        return [\"LEFT\", \"RIGHT\"].filter(\n          x => x !== preferedSecondary\n        )[0] as Side;\n      } else {\n        return [\"TOP\", \"BOTTOM\"].filter(\n          x => x !== preferedSecondary\n        )[0] as Side;\n      }\n    }\n\n    case 3:\n    case 6: {\n      if (prefferedIsY) {\n        return preferedPrimary === \"BOTTOM\" ? \"TOP\" : \"BOTTOM\";\n      }\n\n      return preferedPrimary === \"LEFT\" ? \"RIGHT\" : \"LEFT\";\n    }\n\n    case 5:\n    case 8: {\n      if (prefferedIsY) {\n        return preferedPrimary === \"BOTTOM\" ? \"BOTTOM\" : \"TOP\";\n      }\n\n      return preferedPrimary === \"LEFT\" ? \"LEFT\" : \"RIGHT\";\n    }\n  }\n\n  /* istanbul ignore next */\n  return \"LEFT\";\n}\n\nexport function getSecondaryAnchorOptionsByPrimary(\n  primary: Primary,\n  anchorOptions: AnchorEnum[]\n) {\n  return anchorOptions.filter(anchor => anchor.startsWith(primary));\n}\n\ntype SplitAnchor = {\n  primary: Primary;\n  secondary: Side;\n};\n\nexport function splitAnchor(anchor: AnchorEnum): SplitAnchor {\n  const [primary, secondary] = anchor.split(\"_\") as [Primary, Side];\n\n  return { primary, secondary };\n}\n\nexport function getLayerSideByAnchor(anchor: AnchorEnum): LayerSide {\n  if (anchor === \"CENTER\") {\n    return \"center\";\n  }\n\n  return splitAnchor(anchor).primary.toLowerCase() as LayerSide;\n}\n\nexport function getAnchorPriority(\n  preferedAnchor: AnchorEnum,\n  possibleAnchors: AnchorEnum[],\n  preferedX: \"LEFT\" | \"RIGHT\",\n  preferedY: \"TOP\" | \"BOTTOM\"\n) {\n  const { primary, secondary } =\n    preferedAnchor !== \"CENTER\"\n      ? splitAnchor(preferedAnchor)\n      : {\n          primary: preferedY as Primary,\n          secondary: \"CENTER\" as Side\n        };\n\n  let anchors = POSSIBLE_ANCHORS.map((_, index) => {\n    return `${getPrimaryByIndex(\n      index,\n      primary,\n      preferedX,\n      preferedY\n    )}_${getSecondaryByIndex(index, primary, secondary)}` as AnchorEnum;\n  }).filter(anchor => possibleAnchors.indexOf(anchor) > -1);\n\n  // include prefered anchor if not included in possibleAnchors\n  if (anchors.indexOf(preferedAnchor) === -1) {\n    /* istanbul ignore next */\n    anchors = [preferedAnchor, ...anchors];\n  }\n\n  return anchors;\n}\n","import { Rects, Primary, Side, Direction, AnchorEnum } from \"../types\";\n\nimport { splitAnchor, getPrimaryDirection } from \"../anchor\";\n\ntype PositionGetterArguments = {\n  rects: Rects;\n  scrollTop: number;\n  scrollLeft: number;\n  triggerOffset: number;\n  offsetSecondary: number;\n  primaryDirection: Direction;\n};\n\ntype PositionGetter = (args: PositionGetterArguments) => React.CSSProperties;\n\nconst primaryStyleGetters: Record<Primary, PositionGetter> = {\n  BOTTOM: ({ rects, scrollTop, triggerOffset }) => {\n    const { trigger, relativeParent } = rects;\n    return {\n      top:\n        trigger.top +\n        trigger.height -\n        (relativeParent.top - scrollTop) +\n        triggerOffset\n    };\n  },\n  TOP: ({ rects, scrollTop, triggerOffset }) => {\n    const { trigger, relativeParent, layer } = rects;\n    return {\n      top:\n        trigger.top -\n        layer.height -\n        (relativeParent.top - scrollTop) -\n        triggerOffset\n    };\n  },\n  LEFT: ({ rects, scrollLeft, triggerOffset }) => {\n    const { trigger, relativeParent, layer } = rects;\n\n    return {\n      left:\n        trigger.left -\n        layer.width -\n        (relativeParent.left - scrollLeft) -\n        triggerOffset\n    };\n  },\n  RIGHT: ({ rects, scrollLeft, triggerOffset }) => {\n    const { trigger, relativeParent } = rects;\n    return {\n      left:\n        trigger.left -\n        relativeParent.left +\n        scrollLeft +\n        trigger.width +\n        triggerOffset\n    };\n  }\n};\n\nconst secondaryStyleGetters: Record<Side, PositionGetter> = {\n  TOP: ({ rects, scrollTop, offsetSecondary }) => {\n    const { trigger, relativeParent } = rects;\n    return {\n      top: trigger.top - relativeParent.top + scrollTop + offsetSecondary\n    };\n  },\n  BOTTOM: ({ rects, scrollTop, offsetSecondary }) => {\n    const { trigger, relativeParent, layer } = rects;\n\n    return {\n      top:\n        trigger.bottom -\n        layer.height -\n        (relativeParent.top - scrollTop) -\n        offsetSecondary\n    };\n  },\n  CENTER: ({\n    rects,\n    scrollTop,\n    scrollLeft,\n    primaryDirection,\n    offsetSecondary\n  }) => {\n    const { trigger, relativeParent, layer } = rects;\n\n    if (primaryDirection === \"Y\") {\n      return {\n        left:\n          trigger.left -\n          relativeParent.left +\n          scrollLeft +\n          trigger.width / 2 -\n          layer.width / 2 -\n          offsetSecondary\n      };\n    }\n\n    return {\n      top:\n        trigger.top -\n        relativeParent.top +\n        scrollTop +\n        trigger.height / 2 -\n        layer.height / 2 +\n        offsetSecondary\n    };\n  },\n  LEFT: ({ rects, scrollLeft, offsetSecondary }) => {\n    const { trigger, relativeParent } = rects;\n    return {\n      left: trigger.left - relativeParent.left + scrollLeft + offsetSecondary\n    };\n  },\n  RIGHT: ({ rects, scrollLeft, offsetSecondary }) => {\n    const { trigger, relativeParent, layer } = rects;\n\n    return {\n      left:\n        trigger.right -\n        layer.width -\n        (relativeParent.left - scrollLeft) -\n        offsetSecondary\n    };\n  }\n};\n\nconst centerGetter: PositionGetter = ({ rects, scrollTop, scrollLeft }) => {\n  const { trigger, relativeParent, layer } = rects;\n\n  const left =\n    trigger.left -\n    relativeParent.left +\n    scrollLeft +\n    trigger.width / 2 -\n    layer.width / 2;\n\n  const top =\n    trigger.top -\n    relativeParent.top +\n    scrollTop +\n    trigger.height / 2 -\n    layer.height / 2;\n\n  return {\n    top,\n    left\n  };\n};\n\ntype GetAbsolutePositionsArgs = {\n  anchor: AnchorEnum;\n  rects: Rects;\n  scrollTop: number;\n  scrollLeft: number;\n  triggerOffset: number;\n  offsetSecondary: number;\n};\n\nexport default function getAbsolutePositions({\n  anchor,\n  rects,\n  triggerOffset,\n  offsetSecondary,\n  scrollLeft,\n  scrollTop\n}: GetAbsolutePositionsArgs) {\n  if (anchor === \"CENTER\") {\n    return centerGetter({\n      rects,\n      triggerOffset,\n      offsetSecondary,\n      scrollLeft,\n      scrollTop,\n      primaryDirection: \"Y\"\n    });\n  }\n\n  const { primary, secondary } = splitAnchor(anchor);\n\n  const primaryDirection = getPrimaryDirection(anchor);\n\n  const primaryStyle = primaryStyleGetters[primary]({\n    rects,\n    triggerOffset,\n    offsetSecondary,\n    scrollLeft,\n    scrollTop,\n    primaryDirection\n  });\n  const secondaryStyle = secondaryStyleGetters[secondary]({\n    rects,\n    triggerOffset,\n    offsetSecondary,\n    scrollLeft,\n    scrollTop,\n    primaryDirection\n  });\n\n  return {\n    ...primaryStyle,\n    ...secondaryStyle\n  };\n}\n","import {\n  Direction,\n  Primary,\n  Side,\n  AnchorEnum,\n  LayerDimensions\n} from \"../types\";\n\nimport {\n  splitAnchor,\n  getPrimaryDirection,\n  getLayerSideByAnchor\n} from \"../anchor\";\n\n// if user provided `layerDimensions` to the `placement` prop,\n// anticipate the width / height based on the current anchor\nfunction fixLayerDimensions(\n  originalLayer: ClientRect,\n  anchor: AnchorEnum,\n  layerDimensions: LayerDimensions\n): ClientRect {\n  const dimensions =\n    typeof layerDimensions === \"function\"\n      ? layerDimensions(getLayerSideByAnchor(anchor))\n      : layerDimensions;\n\n  return {\n    top: originalLayer.top,\n    left: originalLayer.left,\n    right: originalLayer.right,\n    bottom: originalLayer.bottom,\n    width: dimensions.width,\n    height: dimensions.height\n  };\n}\n\ntype LayerRectGetter = (args: {\n  trigger: ClientRect;\n  layer: ClientRect;\n  primaryDirection: Direction;\n  triggerOffset: number;\n  offsetSecondary: number;\n}) => Partial<ClientRect>;\n\nconst primaryLayerRectGetters: Record<Primary, LayerRectGetter> = {\n  TOP: ({ trigger, layer, triggerOffset }) => {\n    const bottom = trigger.top - triggerOffset;\n    return {\n      bottom,\n      top: bottom - layer.height\n    };\n  },\n  BOTTOM: ({ trigger, layer, triggerOffset }) => {\n    const top = trigger.bottom + triggerOffset;\n\n    return {\n      top,\n      bottom: top + layer.height\n    };\n  },\n  LEFT: ({ trigger, layer, triggerOffset }) => {\n    const right = trigger.left - triggerOffset;\n    return {\n      right,\n      left: right - layer.width\n    };\n  },\n  RIGHT: ({ trigger, layer, triggerOffset }) => {\n    const left = trigger.right + triggerOffset;\n\n    return {\n      left,\n      right: left + layer.width\n    };\n  }\n};\n\nconst secondaryLayerRectGetters: Record<Side, LayerRectGetter> = {\n  TOP: ({ trigger, layer, offsetSecondary }) => {\n    const top = trigger.top + offsetSecondary;\n    return {\n      top,\n      bottom: top + layer.height\n    };\n  },\n  BOTTOM: ({ trigger, layer, offsetSecondary }) => {\n    const bottom = trigger.bottom - offsetSecondary;\n\n    return {\n      bottom,\n      top: bottom - layer.height\n    };\n  },\n  LEFT: ({ trigger, layer, offsetSecondary }) => {\n    const left = trigger.left + offsetSecondary;\n\n    return {\n      left,\n      right: left + layer.width\n    };\n  },\n  RIGHT: ({ trigger, layer, offsetSecondary }) => {\n    const right = trigger.right - offsetSecondary;\n\n    return {\n      right,\n      left: right - layer.width\n    };\n  },\n  CENTER: ({ trigger, layer, primaryDirection, offsetSecondary }) => {\n    if (primaryDirection === \"Y\") {\n      const left =\n        trigger.left + trigger.width / 2 - layer.width / 2 - offsetSecondary;\n      return {\n        left,\n        right: left + layer.width\n      };\n    }\n\n    const top =\n      trigger.top + trigger.height / 2 - layer.height / 2 + offsetSecondary;\n    return {\n      top,\n      bottom: top + layer.height\n    };\n  }\n};\n\ntype GetLayerRectArgs = {\n  trigger: ClientRect;\n  layer: ClientRect;\n  anchor: AnchorEnum;\n  triggerOffset: number;\n  scrollOffset?: number;\n  offsetSecondary?: number;\n  layerDimensions?: LayerDimensions;\n};\n\nexport default function getLayerRectByAnchor({\n  trigger,\n  layer,\n  anchor,\n  triggerOffset,\n  scrollOffset = 0,\n  offsetSecondary = 0,\n  layerDimensions\n}: GetLayerRectArgs): ClientRect {\n  let primaryRect: Partial<ClientRect>;\n  let secondaryRect: Partial<ClientRect>;\n\n  const layerRect = layerDimensions\n    ? fixLayerDimensions(layer, anchor, layerDimensions)\n    : layer;\n\n  if (anchor === \"CENTER\") {\n    primaryRect = secondaryLayerRectGetters.CENTER({\n      trigger,\n      layer: layerRect,\n      primaryDirection: \"Y\",\n      triggerOffset,\n      offsetSecondary\n    });\n    secondaryRect = secondaryLayerRectGetters.CENTER({\n      trigger,\n      layer: layerRect,\n      primaryDirection: \"X\",\n      triggerOffset,\n      offsetSecondary\n    });\n  } else {\n    const { primary, secondary } = splitAnchor(anchor);\n\n    const primaryDirection = getPrimaryDirection(anchor);\n\n    primaryRect = primaryLayerRectGetters[primary]({\n      trigger,\n      layer: layerRect,\n      primaryDirection,\n      triggerOffset,\n      offsetSecondary\n    });\n    secondaryRect = secondaryLayerRectGetters[secondary]({\n      trigger,\n      layer: layerRect,\n      primaryDirection,\n      triggerOffset,\n      offsetSecondary\n    });\n  }\n\n  const result = {\n    ...layer,\n    ...primaryRect,\n    ...secondaryRect,\n    width: layerRect.width,\n    height: layerRect.height\n  };\n\n  result.top = result.top - scrollOffset;\n  result.right = result.right + scrollOffset;\n  result.left = result.left - scrollOffset;\n  result.bottom = result.bottom + scrollOffset;\n\n  return result;\n}\n","import { Rects, AnchorEnum, OffsetSide, LayerDimensions } from \"../types\";\nimport getLayerRectByAnchor from \"./getLayerRectByAnchor\";\n\nconst ALL_OFFSET_SIDES: OffsetSide[] = [\"bottom\", \"top\", \"left\", \"right\"];\n\ntype LayerOffsets = Record<OffsetSide, number>;\n\nfunction getLayerOffsetsToParent(\n  layer: ClientRect,\n  parent: ClientRect\n): LayerOffsets {\n  return {\n    top: layer.top - parent.top,\n    bottom: parent.bottom - layer.bottom,\n    left: layer.left - parent.left,\n    right: parent.right - layer.right\n  };\n}\n\nfunction getLayerOffsetsToParents(layer: ClientRect, parents: ClientRect[]) {\n  return parents.map(parent => getLayerOffsetsToParent(layer, parent));\n}\n\nexport function isLayerCompletelyInvisible(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  return parents.some(parent => {\n    return (\n      layer.bottom <= parent.top ||\n      layer.right <= parent.left ||\n      layer.top >= parent.bottom ||\n      layer.left >= parent.right\n    );\n  });\n}\n\nexport function doesEntireLayerFitWithinScrollParents(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  const parentOffsets = getLayerOffsetsToParents(layer, parents);\n\n  return parentOffsets.every(offsets => {\n    return ALL_OFFSET_SIDES.every(side => offsets[side] >= 0);\n  });\n}\n\nexport function reduceOffsets(parentOffsets: LayerOffsets[]): LayerOffsets {\n  const parentOffsetsCombined = parentOffsets.reduce(\n    (result, offsets) => {\n      ALL_OFFSET_SIDES.forEach(side => {\n        result[side] = [...result[side], offsets[side]];\n      });\n      return result;\n    },\n    {\n      top: [] as number[],\n      bottom: [] as number[],\n      left: [] as number[],\n      right: [] as number[]\n    }\n  );\n\n  return ALL_OFFSET_SIDES.reduce(\n    (result, side) => {\n      result[side] = parentOffsetsCombined[side].sort((a, b) => a - b)[0];\n      return result;\n    },\n    {} as LayerOffsets\n  );\n}\n\nexport function getNegativeOffsetSides(parentOffsets: LayerOffsets[]) {\n  const offsets = reduceOffsets(parentOffsets);\n\n  return ALL_OFFSET_SIDES.filter(side => offsets[side] < 0);\n}\n\nfunction getVisibleLayerSurface(layer: ClientRect, parent: ClientRect) {\n  const offsets = getLayerOffsetsToParent(layer, parent);\n\n  const visibleRect = ALL_OFFSET_SIDES.filter(side => offsets[side] < 0).reduce(\n    (rect, side) => {\n      const affectedProperty: \"width\" | \"height\" =\n        side === \"top\" || side === \"bottom\" ? \"height\" : \"width\";\n\n      return {\n        ...rect,\n        [affectedProperty]: rect[affectedProperty] + offsets[side]\n      };\n    },\n    layer\n  );\n\n  return visibleRect.width * visibleRect.height;\n}\n\nexport function getVisibleLayerSurfaceWithinScrollParent(\n  layer: ClientRect,\n  parents: ClientRect[]\n) {\n  const surfaces = parents.map(parent => getVisibleLayerSurface(layer, parent));\n\n  // pick smallest\n  return surfaces.sort((a, b) => a - b)[0];\n}\n\nexport function doesAnchorFitWithinScrollParents(\n  anchor: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions?: LayerDimensions\n) {\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions\n  });\n  return doesEntireLayerFitWithinScrollParents(layerRect, rects.scrollParents);\n}\n\nexport function getLayerOffsetsToScrollParentsByAnchor(\n  anchor: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  return getLayerOffsetsToParents(\n    getLayerRectByAnchor({\n      anchor,\n      trigger: rects.trigger,\n      layer: rects.layer,\n      triggerOffset,\n      scrollOffset\n    }),\n    rects.scrollParents\n  );\n}\n\n// export function getLayerSide(\n//   layer: ClientRect,\n//   trigger: ClientRect\n// ): LayerSide {\n//   if (layer.top >= trigger.bottom) {\n//     return \"bottom\";\n//   }\n//   if (layer.left >= trigger.right) {\n//     return \"right\";\n//   }\n//   if (layer.bottom <= trigger.top) {\n//     return \"top\";\n//   }\n\n//   return \"left\";\n// }\n","import { Rects, AnchorEnum, LayerDimensions } from \"../types\";\nimport { getPrimaryDirection } from \"../anchor\";\nimport {\n  doesAnchorFitWithinScrollParents,\n  getVisibleLayerSurfaceWithinScrollParent\n} from \"../rect\";\nimport getLayerRectByAnchor from \"../rect/getLayerRectByAnchor\";\n\nfunction getOffsetSurface(\n  anchor: AnchorEnum,\n  layer: ClientRect,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  const primaryDirection = getPrimaryDirection(anchor);\n\n  const primarySize =\n    layer[primaryDirection === \"X\" ? \"width\" : \"height\"] -\n    triggerOffset -\n    scrollOffset * 2;\n\n  const secondarySize =\n    layer[primaryDirection === \"X\" ? \"height\" : \"width\"] -\n    triggerOffset -\n    scrollOffset * 2;\n\n  return primarySize * secondarySize;\n}\n\nfunction findAnchorByLayerSurface(\n  rects: Rects,\n  anchorOptions: AnchorEnum[],\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions?: LayerDimensions\n): AnchorEnum {\n  const result = anchorOptions\n    .map(anchor => {\n      // get layerRect based on all offsets\n      const layerRect = getLayerRectByAnchor({\n        anchor,\n        layer: rects.layer,\n        trigger: rects.trigger,\n        scrollOffset,\n        triggerOffset,\n        layerDimensions\n      });\n\n      // get smallest visible layer surface for current anchor\n      const surface = getVisibleLayerSurfaceWithinScrollParent(\n        layerRect,\n        rects.scrollParents\n      );\n\n      // get surface of the offsets\n      // offsets are important for collision detection, but\n      // eventually we are interested in the 'meat' of the layer\n      const offsetSurface = getOffsetSurface(\n        anchor,\n        layerRect,\n        triggerOffset,\n        scrollOffset\n      );\n\n      return {\n        anchor,\n        square: surface - offsetSurface\n      };\n    })\n    // sort -> biggest surface first\n    .sort((a, b) => b.square - a.square);\n\n  return result[0].anchor;\n}\n\nexport default function findBestSuitableAnchor(\n  rects: Rects,\n  anchorOptions: AnchorEnum[],\n  triggerOffset: number,\n  scrollOffset: number,\n  layerDimensions?: LayerDimensions\n): AnchorEnum {\n  // STRATEGY A\n  // find first that fits parent\n  const anchor = anchorOptions.find(anchor =>\n    doesAnchorFitWithinScrollParents(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset,\n      layerDimensions\n    )\n  );\n\n  if (anchor) {\n    return anchor;\n  }\n\n  // STRATEGY B\n  // find first with biggest surface\n  return findAnchorByLayerSurface(\n    rects,\n    anchorOptions,\n    triggerOffset,\n    scrollOffset,\n    layerDimensions\n  );\n}\n","import { Rects, AnchorEnum, OffsetSide } from \"../types\";\nimport {\n  getLayerOffsetsToScrollParentsByAnchor,\n  getNegativeOffsetSides,\n  doesAnchorFitWithinScrollParents,\n  reduceOffsets\n} from \"../rect\";\nimport {\n  splitAnchor,\n  getPrimaryDirection,\n  getSecondaryAnchorOptionsByPrimary\n} from \"../anchor\";\n\n// finds out which side of the layer will be affected\nfunction getSecondaryOffsetSide(\n  currentAnchor: AnchorEnum,\n  firstAnchorThatDoesNotFit: AnchorEnum,\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n): OffsetSide | undefined {\n  const primaryDirection = getPrimaryDirection(currentAnchor);\n\n  const offsets = getLayerOffsetsToScrollParentsByAnchor(\n    firstAnchorThatDoesNotFit,\n    rects,\n    triggerOffset,\n    scrollOffset\n  );\n\n  const sides = getNegativeOffsetSides(offsets);\n\n  return sides.find(side => {\n    if (primaryDirection === \"X\") {\n      return side === \"top\" || side === \"bottom\";\n    }\n\n    return side === \"left\" || side === \"right\";\n  });\n}\n\nexport default function findSecondaryOffset(\n  anchor: AnchorEnum,\n  anchorOptions: AnchorEnum[],\n  rects: Rects,\n  triggerOffset: number,\n  scrollOffset: number\n) {\n  const { primary } = splitAnchor(anchor);\n\n  /**\n   * A.\n   * Check wether there are other anchors available\n   * If not, skip secondary offset\n   */\n  const secondaryAnchorOptions = getSecondaryAnchorOptionsByPrimary(\n    primary,\n    anchorOptions\n  );\n\n  if (secondaryAnchorOptions.length === 1) {\n    return 0;\n  }\n\n  /**\n   * B.\n   * Check whether current anchor is the preffered anchor and whether\n   * it fits\n   * If so, skip secondary offset\n   */\n  const currentAnchorHasHighestPriority =\n    secondaryAnchorOptions.indexOf(anchor) === 0;\n  const currentAnchorFits = doesAnchorFitWithinScrollParents(\n    anchor,\n    rects,\n    triggerOffset,\n    scrollOffset\n  );\n\n  if (currentAnchorHasHighestPriority && currentAnchorFits) {\n    return 0;\n  }\n\n  /**\n   * C.\n   * Retrieve the first anchor on same primary side (by priority) that\n   * does not fit.\n   * Check if there's a relevant side that has a negative offset.\n   * If not, skip secondary offset\n   */\n  const firstAnchorThatDoesNotFit = secondaryAnchorOptions.find(anchor => {\n    return !doesAnchorFitWithinScrollParents(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset\n    );\n  })!;\n\n  const affectedSide = getSecondaryOffsetSide(\n    anchor,\n    firstAnchorThatDoesNotFit,\n    rects,\n    triggerOffset,\n    scrollOffset\n  );\n\n  if (!affectedSide) {\n    return 0;\n  }\n\n  /**\n   * Determine the final secondary offset\n   */\n  const currentOffsets = reduceOffsets(\n    getLayerOffsetsToScrollParentsByAnchor(\n      anchor,\n      rects,\n      triggerOffset,\n      scrollOffset\n    )\n  );\n\n  // ensure `secondaryOffset` is always negative or 0\n  let secondaryOffset = Math.min(-currentOffsets[affectedSide], 0);\n\n  // when current anchor is center, make `secondaryOffset` positive\n  // when affectedSide is bottom or right\n  const isCenter = anchor.includes(\"_CENTER\");\n  if (isCenter && (affectedSide === \"bottom\" || affectedSide === \"left\")) {\n    secondaryOffset = -secondaryOffset;\n  }\n\n  return secondaryOffset;\n}\n","import { LayerSide } from \"../types\";\n\nexport default function getArrowStyle(\n  layer: ClientRect,\n  trigger: ClientRect,\n  layerSide: LayerSide\n): React.CSSProperties {\n  if (layerSide === \"bottom\") {\n    return {\n      bottom: \"100%\",\n      top: null,\n      left: trigger.left + trigger.width / 2 - layer.left,\n      right: null\n    } as any;\n  }\n  if (layerSide === \"right\") {\n    return {\n      right: \"100%\",\n      left: null,\n      top: trigger.top + trigger.height / 2 - layer.top,\n      bottom: null\n    } as any;\n  }\n  if (layerSide === \"top\") {\n    return {\n      top: \"100%\",\n      bottom: null,\n      left: trigger.left + trigger.width / 2 - layer.left,\n      right: null\n    } as any;\n  }\n\n  return {\n    left: \"100%\",\n    right: null,\n    top: trigger.top + trigger.height / 2 - layer.top,\n    bottom: null\n  } as any;\n}\n","import {\n  Rects,\n  AnchorEnum,\n  PreferedX,\n  PreferedY,\n  LayerDimensions\n} from \"../types\";\n\nimport { getAnchorPriority } from \"../anchor\";\n\nimport getAbsolutePositions from \"./getAbsolutePositions\";\nimport getSuitableAnchor from \"./getSuitableAnchor\";\nimport getSecondaryOffset from \"./getSecondaryOffset\";\nimport getLayerRectByAnchor from \"../rect/getLayerRectByAnchor\";\n\nexport { default as getArrowStyle } from \"./getArrowStyle\";\n\ntype GetAutoAdjustStyleArgs = {\n  rects: Rects;\n  scrollTop: number;\n  scrollLeft: number;\n  triggerOffset: number;\n  scrollOffset: number;\n  preferedAnchor: AnchorEnum;\n  preferedX: PreferedX;\n  preferedY: PreferedY;\n  possibleAnchors: AnchorEnum[];\n  autoAdjust: boolean;\n  snapToAnchor: boolean;\n  layerDimensions?: LayerDimensions;\n};\n\nexport default function getAbsoluteStyle({\n  rects,\n  scrollTop,\n  scrollLeft,\n  triggerOffset,\n  scrollOffset,\n  possibleAnchors,\n  preferedAnchor,\n  preferedX,\n  preferedY,\n  autoAdjust,\n  snapToAnchor,\n  layerDimensions\n}: GetAutoAdjustStyleArgs): {\n  layerStyle: React.CSSProperties;\n  layerRect: ClientRect;\n  anchor: AnchorEnum;\n} {\n  // get a list of possible anchors bases on user set props\n  const possibleAnchorsByPriority = getAnchorPriority(\n    preferedAnchor,\n    possibleAnchors,\n    preferedX,\n    preferedY\n  );\n\n  // on `autoAdjust` find best suitable anchor based on\n  // window's / scrollParent's position\n  const anchor = autoAdjust\n    ? getSuitableAnchor(\n        rects,\n        possibleAnchorsByPriority,\n        triggerOffset,\n        scrollOffset,\n        layerDimensions\n      )\n    : preferedAnchor;\n\n  // calculate a secondary offset when `autoAdjust` is set\n  // and `snapToAnchor` is not.\n  // Basically it creates a visual effect where it seems that\n  // the layer has glued to it's parents sides\n  // Note: `offsetSecondary` is disabled when anchor is CENTER\n  const offsetSecondary =\n    autoAdjust && !snapToAnchor && anchor !== \"CENTER\"\n      ? getSecondaryOffset(\n          anchor,\n          possibleAnchorsByPriority,\n          rects,\n          triggerOffset,\n          scrollOffset\n        )\n      : 0;\n\n  const layerStyle = getAbsolutePositions({\n    anchor,\n    rects,\n    triggerOffset,\n    offsetSecondary,\n    scrollLeft,\n    scrollTop\n  });\n\n  const layerRect = getLayerRectByAnchor({\n    anchor,\n    trigger: rects.trigger,\n    layer: rects.layer,\n    triggerOffset,\n    offsetSecondary,\n    layerDimensions\n  });\n\n  if (layerDimensions) {\n    layerStyle.width = layerRect.width;\n    layerStyle.height = layerRect.height;\n  }\n\n  return {\n    layerStyle,\n    layerRect,\n    anchor\n  };\n}\n","import * as React from \"react\";\nimport {\n  AnchorEnum,\n  PreferedX,\n  PreferedY,\n  LayerSide,\n  LayerDimensions\n} from \"./types\";\nimport Layer from \"./Layer\";\n\nimport useOutsideClick from \"./useOutsideClick\";\nimport useOnScroll from \"./useOnScroll\";\nimport useElementRef from \"./useElementRef\";\nimport useOnWindowResize from \"./useOnWindowResize\";\nimport useTrackElementResize from \"./useTrackElementResize\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport compensateScrollbars from \"./compensateScrollbars\";\nimport findScrollContainers from \"./findScrollContainers\";\n\nimport {\n  EMPTY_STYLE,\n  isSet,\n  shouldUpdateStyles,\n  getWindowClientRect,\n  getContentBox\n} from \"./util\";\n\nimport getAbsoluteStyle, { getArrowStyle } from \"./style\";\n\nimport { POSSIBLE_ANCHORS, getLayerSideByAnchor } from \"./anchor\";\n\nimport {\n  doesEntireLayerFitWithinScrollParents,\n  isLayerCompletelyInvisible\n} from \"./rect\";\n\ntype RenderChildrenProps = {\n  isOpen: boolean;\n  open: () => void;\n  close: () => void;\n  toggle: () => void;\n  triggerRef: React.RefObject<any>;\n  layerSide: LayerSide | null;\n};\n\ntype Placement = {\n  anchor: AnchorEnum;\n  triggerOffset?: number;\n  scrollOffset?: number;\n  possibleAnchors?: AnchorEnum[];\n  autoAdjust?: boolean;\n  snapToAnchor?: boolean;\n  preferX?: PreferedX;\n  preferY?: PreferedY;\n  layerDimensions?: LayerDimensions;\n};\n\ntype DisappearType = \"partial\" | \"full\";\n\nexport type ResultingStyles = {\n  layer: React.CSSProperties;\n  arrow: React.CSSProperties;\n  layerSide: LayerSide;\n};\n\ntype RenderLayerProps = {\n  layerProps: {\n    ref: (element: HTMLElement | null) => void;\n    style: React.CSSProperties;\n  };\n  arrowStyle: React.CSSProperties;\n  layerSide: LayerSide;\n  triggerRect: ClientRect | null;\n  isOpen: boolean;\n  close: () => void;\n};\n\nexport type Props = {\n  children: (childrenProps: RenderChildrenProps) => React.ReactNode;\n  renderLayer: (props: RenderLayerProps) => React.ReactNode;\n  isOpen?: boolean;\n  placement: Placement;\n  onStyle?: (\n    layerStyle: React.CSSProperties,\n    arrowStyle: React.CSSProperties,\n    layerSide: LayerSide\n  ) => void;\n  closeOnOutsideClick?: boolean;\n  onOutsideClick?: () => void;\n  closeOnDisappear?: DisappearType;\n  onDisappear?: (type: DisappearType) => void;\n  ResizeObserver?: any;\n  fixed?: boolean;\n  container?: HTMLElement | (() => HTMLElement);\n};\n\ntype UseTriggerElementState = {\n  triggerElement: HTMLElement | null;\n  relativeParentElement: HTMLElement | null;\n  scrollParents: HTMLElement[];\n};\n\nfunction ToggleLayer({\n  children,\n  renderLayer,\n  placement,\n  onStyle,\n  isOpen: isOpenExternal,\n  closeOnOutsideClick,\n  onOutsideClick,\n  onDisappear,\n  closeOnDisappear,\n  fixed,\n  container,\n  ...props\n}: Props) {\n  /**\n   * Tracks trigger element and keeps it in state together with it's\n   * relative/absolute positioned parent\n   */\n  const [\n    triggerRef,\n    { relativeParentElement, triggerElement, scrollParents }\n  ] = useElementRef<UseTriggerElementState>(\n    { triggerElement: null, relativeParentElement: null, scrollParents: [] },\n    React.useCallback((triggerElement: HTMLElement) => {\n      const scrollParents = findScrollContainers(triggerElement);\n\n      const relativeParentElement = scrollParents[0] || document.body;\n\n      if (relativeParentElement === document.body) {\n        document.body.style.position = \"relative\";\n      } else if (process.env.NODE_ENV === \"development\") {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const containerElement =\n          typeof container === \"function\" ? container() : container;\n\n        const position = window.getComputedStyle(relativeParentElement)\n          .position;\n        const shouldWarnAboutPositionStyle =\n          position !== \"relative\" &&\n          position !== \"absolute\" &&\n          position !== \"fixed\" &&\n          !fixed &&\n          !containerElement;\n\n        if (shouldWarnAboutPositionStyle) {\n          console.warn(\n            `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'fixed' prop to true. This is needed in order to position the layers properly. Currently the scroll-container is positioned: \"${position}\". Visit https://react-laag.com/docs/#position-relative for more info.`,\n            relativeParentElement\n          );\n        }\n      }\n\n      return {\n        triggerElement,\n        relativeParentElement,\n        scrollParents\n      };\n    }, [])\n  );\n\n  const [INITIAL_STYLES] = React.useState<ResultingStyles>({\n    layer: EMPTY_STYLE,\n    arrow: EMPTY_STYLE,\n    layerSide: placement.anchor.split(\"_\")[0].toLowerCase() as LayerSide\n  });\n\n  const [styles, setStyles] = React.useState<ResultingStyles>(INITIAL_STYLES);\n  const lastStyles = React.useRef<ResultingStyles>(styles);\n\n  const layerRef = React.useRef<HTMLElement | null>(null);\n\n  const [isOpenInternal, setOpenInternal] = React.useState(false);\n\n  const isOpen = isSet(isOpenExternal) ? isOpenExternal! : isOpenInternal;\n\n  const calculateNewLayerStyle = React.useCallback(() => {\n    /**\n     * A.\n     * Calculate new layer positions\n     */\n\n    const triggerRect = triggerElement!.getBoundingClientRect();\n\n    // sometimes ResizeObserver calls this function when all values in the\n    // trigger ClientRect are 0. Return early in that case\n    if (triggerRect.height === 0) {\n      return;\n    }\n\n    if (!layerRef.current) {\n      return;\n    }\n\n    // gather all scroll parents (including the window ClientRect)\n    // in order to check for collisions\n    const scrollParentRects = fixed\n      ? [getWindowClientRect()]\n      : [\n          ...scrollParents.map(parent =>\n            compensateScrollbars(\n              parent.getBoundingClientRect(),\n              parent.clientWidth,\n              parent.clientHeight\n            )\n          ),\n          getWindowClientRect()\n        ];\n\n    const options = {\n      autoAdjust: placement.autoAdjust || false,\n      snapToAnchor: placement.snapToAnchor || false,\n      triggerOffset: placement.triggerOffset || 0,\n      scrollOffset: placement.scrollOffset || 0,\n      possibleAnchors: placement.possibleAnchors || POSSIBLE_ANCHORS,\n      preferedAnchor: placement.anchor,\n      preferedX: placement.preferX || \"RIGHT\",\n      preferedY: placement.preferY || \"BOTTOM\",\n      scrollLeft:\n        relativeParentElement === document.body\n          ? 0\n          : relativeParentElement!.scrollLeft,\n      scrollTop:\n        relativeParentElement === document.body\n          ? 0\n          : relativeParentElement!.scrollTop,\n      relativeParentElement,\n      layerDimensions: placement.layerDimensions\n    };\n\n    const layerBox = layerRef.current!.getBoundingClientRect();\n\n    // construct layerRect\n    const layer = {\n      top: layerBox.top,\n      left: layerBox.left,\n      right: layerBox.right,\n      bottom: layerBox.bottom,\n\n      // use `window.getComputedProperty` for width / height in order\n      // to handle things like scale-transforms\n      ...getContentBox(layerRef.current!)\n    };\n\n    const rects = {\n      layer,\n      relativeParent: relativeParentElement!.getBoundingClientRect(),\n      scrollParents: scrollParentRects,\n      trigger: triggerRect\n    };\n\n    const { layerRect, layerStyle, anchor } = getAbsoluteStyle({\n      rects,\n      ...options\n    });\n\n    if (fixed) {\n      layerStyle.top = layerRect.top;\n      layerStyle.left = layerRect.left;\n    }\n\n    // determine in which side to layer will be relative to\n    // the trigger\n    const layerSide = getLayerSideByAnchor(anchor);\n\n    // get optional arrow positions\n    // anchor-style is pointless when rendered anchor is CENTER\n    const arrowStyle =\n      anchor === \"CENTER\"\n        ? EMPTY_STYLE\n        : getArrowStyle(layerRect, triggerRect, layerSide);\n\n    const newStyles: ResultingStyles = {\n      layer: layerStyle,\n      arrow: arrowStyle,\n      layerSide\n    };\n\n    // only update styles when necessary\n    if (shouldUpdateStyles(lastStyles.current, newStyles)) {\n      // is parent in control of styles? (onStyle)\n      if (isSet(onStyle)) {\n        lastStyles.current = newStyles;\n        onStyle!(newStyles.layer, newStyles.arrow, layerSide);\n      }\n      // ... otherwise set styles internally\n      else {\n        setStyles(newStyles);\n      }\n    }\n\n    /**\n     * B.\n     * Manage disappearance\n     */\n\n    const hasOnDisappear = isSet(onDisappear);\n    const shouldCloseOnDisappear = closeOnDisappear && !isSet(isOpenExternal);\n\n    // Should we respond to the layer's partial or full disappearance?\n    // (trigger's disappearance when `fixed` props is set)\n    if (hasOnDisappear || shouldCloseOnDisappear) {\n      const allScrollParents = [\n        ...scrollParents.map(parent => parent.getBoundingClientRect()),\n        getWindowClientRect()\n      ];\n\n      const partial = !doesEntireLayerFitWithinScrollParents(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n      const full = isLayerCompletelyInvisible(\n        fixed ? triggerRect : layerRect,\n        allScrollParents\n      );\n\n      // if parent is interested in diseappearance...\n      if (hasOnDisappear) {\n        onDisappear!(full ? \"full\" : \"partial\");\n      }\n      // ... else close accordingly\n      else {\n        if (closeOnDisappear === \"partial\" && partial) {\n          setOpenInternal(false);\n        }\n        if (closeOnDisappear === \"full\" && full) {\n          setOpenInternal(false);\n        }\n      }\n    }\n  }, [\n    relativeParentElement,\n    isOpen,\n    triggerElement,\n    scrollParents,\n    fixed,\n    placement\n  ]);\n\n  // call `calculateNewLayerStyle` when the layer's / trigger's\n  // height and / or width changes\n  const resizeObserver = useTrackElementResize(\n    props.ResizeObserver,\n    layerRef,\n    triggerElement,\n    isOpen,\n    calculateNewLayerStyle\n  );\n\n  // On every render, check a few things...\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * A.\n     * Ignore when render is caused by internal style change\n     */\n    const styleIsSetInterally = !isSet(onStyle);\n    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;\n\n    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {\n      lastStyles.current = styles;\n      return;\n    }\n\n    // reset lastStyles-ref when closed\n    if (!isOpen) {\n      lastStyles.current = INITIAL_STYLES;\n      return;\n    }\n\n    /**\n     * B.\n     * Prepare to calculate new layer style\n     */\n\n    // if (!triggerElement) {\n    //   throw new Error(\"Please provide a valid ref to the trigger element\");\n    // } else if (!layerRef.current) {\n    //   throw new Error(\"Please provide a valid ref to the layer element\");\n    // }\n\n    calculateNewLayerStyle();\n  });\n\n  // calculate new layer style when window size changes\n  useOnWindowResize(calculateNewLayerStyle, isOpen);\n\n  // calculate new layer style when user scrolls\n  useOnScroll(scrollParents, calculateNewLayerStyle, isOpen);\n\n  // handle clicks that are not originated from the trigger / layer\n  // element\n  useOutsideClick(\n    [{ current: triggerElement }, layerRef],\n    React.useCallback(() => {\n      if (!isOpen) {\n        return;\n      }\n\n      if (onOutsideClick) {\n        onOutsideClick();\n      }\n\n      if (closeOnOutsideClick && !isSet(isOpenExternal)) {\n        setOpenInternal(false);\n      }\n    }, [isOpen, setOpenInternal, isOpenExternal])\n  );\n\n  const containerElement =\n    typeof container === \"function\" ? container() : container;\n\n  return (\n    <>\n      <>\n        {children({\n          isOpen,\n          close: () => {\n            /* istanbul ignore next */\n            if (isSet(isOpenExternal)) {\n              throw new Error(\n                \"You cannot call `close()` while using the `isOpen` prop\"\n              );\n            }\n            /* istanbul ignore next */\n            setOpenInternal(false);\n          },\n          open: () => {\n            /* istanbul ignore next */\n            if (isSet(isOpenExternal)) {\n              throw new Error(\n                \"You cannot call `open()` while using the `isOpen` prop\"\n              );\n            }\n            /* istanbul ignore next */\n            setOpenInternal(true);\n          },\n          toggle: () => {\n            /* istanbul ignore next */\n            if (isSet(isOpenExternal)) {\n              throw new Error(\n                \"You cannot call `toggle()` while using the `isOpen` prop\"\n              );\n            }\n            setOpenInternal(!isOpenInternal);\n          },\n          triggerRef,\n          layerSide: isOpen ? styles.layerSide : null\n        })}\n\n        {relativeParentElement && (\n          <Layer parentElement={containerElement || relativeParentElement}>\n            {renderLayer({\n              layerProps: {\n                ref: element => {\n                  if (element) {\n                    // observe the layer for resizing\n                    // it's ok to observe the same element multiple times\n                    // since multiple observes of same element are ignored\n                    resizeObserver.observe(element!);\n                  }\n\n                  layerRef.current = element;\n                },\n                style: {\n                  ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),\n                  position: fixed ? \"fixed\" : \"absolute\",\n                  willChange: \"top, bottom, left, right, width, height\"\n                }\n              },\n              arrowStyle: {\n                ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),\n                position: \"absolute\",\n                willChange: \"top, bottom, left, right\"\n              },\n              isOpen,\n              layerSide: styles.layerSide,\n              triggerRect: triggerElement\n                ? triggerElement.getBoundingClientRect()\n                : null,\n              close: () => {\n                /* istanbul ignore next */\n                if (isSet(isOpenExternal)) {\n                  throw new Error(\n                    \"You cannot call `close()` while using the `isOpen` prop\"\n                  );\n                }\n                /* istanbul ignore next */\n                setOpenInternal(false);\n              }\n            })}\n          </Layer>\n        )}\n      </>\n    </>\n  );\n}\n\nexport default ToggleLayer;\n","import * as React from \"react\";\n\ntype UseHoverProps = {\n  delayEnter?: number;\n  delayLeave?: number;\n};\n\ntype TimeoutState = \"entering\" | \"leaving\" | null;\n\nexport default function useHover({\n  delayEnter = 0,\n  delayLeave = 0\n}: UseHoverProps) {\n  const [show, setShow] = React.useState(false);\n  const timeoutRef = React.useRef<number | null>(null);\n\n  const timeoutState = React.useRef<TimeoutState>(null);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (timeoutState.current === \"leaving\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }\n\n    if (show) {\n      return;\n    }\n\n    timeoutState.current = \"entering\";\n    timeoutRef.current = setTimeout(() => {\n      setShow(true);\n      timeoutRef.current = null;\n      timeoutState.current = null;\n    }, delayEnter) as any;\n  }\n\n  function onMouseLeave() {\n    // if was waiting for entering,\n    // clear timeout\n    if (timeoutState.current === \"entering\" && timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n\n    if (!show) {\n      return;\n    }\n\n    timeoutState.current = \"leaving\";\n    timeoutRef.current = setTimeout(() => {\n      setShow(false);\n      timeoutRef.current = null;\n    }, delayLeave) as any;\n  }\n\n  // make sure to clear timeout on unmount\n  React.useEffect(() => {\n    const to = timeoutRef.current;\n\n    function onScroll() {\n      if (show) {\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n\n      if (to) {\n        clearTimeout(to);\n      }\n    };\n  }, [show]);\n\n  return [\n    show,\n    {\n      onMouseEnter,\n      onMouseLeave\n    }\n  ] as [boolean, { onMouseEnter: () => void; onMouseLeave: () => void }];\n}\n"],"names":["useCreateDomElement","tag","parentElement","document","body","domElement","setDomElement","React","element","createElement","appendChild","removeChild","Layer","children","React.createElement","createPortal","isChildOf","parent","target","hasChildren","length","i","child","useOutsideClick","refs","callback","useEffect","onClick","evt","ref","current","addEventListener","removeEventListener","useOnScroll","elements","onScroll","trackScroll","handleScroll","window","forEach","el","useElementRef","initialState","elementToState","state","setState","lastElement","setRef","node","useOnWindowResize","onResize","trackResize","handleResize","safeWindow","getter","fallback","useIsomorphicLayoutEffect","useTrackElementResize","injectedResizeObserver","layerRef","triggerElement","isOpen","callbackRef","ResizeObserver","Error","resizeObserver","observe","unobserve","disconnect","compensateScrollbars","rect","clientWidth","clientHeight","scrollbarWidth","width","scrollbarHeight","height","left","top","right","bottom","findScrollContainers","result","overflow","overflowX","overflowY","getComputedStyle","some","prop","push","EMPTY_STYLE","isSet","value","undefined","areStylesTheSame","a","b","aKeys","Object","keys","bKeys","Math","max","key","shouldUpdateStyles","prev","next","layer","arrow","getWindowClientRect","innerWidth","innerHeight","convertFloat","parseFloat","replace","getContentBox","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","reduce","total","Anchor","BOTTOM_LEFT","BOTTOM_RIGHT","BOTTOM_CENTER","TOP_LEFT","TOP_CENTER","TOP_RIGHT","LEFT_BOTTOM","LEFT_CENTER","LEFT_TOP","RIGHT_BOTTOM","RIGHT_CENTER","RIGHT_TOP","POSSIBLE_ANCHORS","getPrimaryDirection","anchor","startsWith","primaryIsY","primary","getPrimaryByIndex","index","preferedPrimary","preferedX","preferedY","prefferedIsY","filter","x","getSecondaryByIndex","preferedSecondary","getSecondaryAnchorOptionsByPrimary","anchorOptions","splitAnchor","secondary","split","getLayerSideByAnchor","toLowerCase","getAnchorPriority","preferedAnchor","possibleAnchors","anchors","map","_","indexOf","primaryStyleGetters","BOTTOM","rects","scrollTop","triggerOffset","trigger","relativeParent","TOP","LEFT","scrollLeft","RIGHT","secondaryStyleGetters","offsetSecondary","CENTER","primaryDirection","centerGetter","getAbsolutePositions","primaryStyle","secondaryStyle","fixLayerDimensions","originalLayer","layerDimensions","dimensions","primaryLayerRectGetters","secondaryLayerRectGetters","getLayerRectByAnchor","scrollOffset","primaryRect","secondaryRect","layerRect","ALL_OFFSET_SIDES","getLayerOffsetsToParent","getLayerOffsetsToParents","parents","isLayerCompletelyInvisible","doesEntireLayerFitWithinScrollParents","parentOffsets","every","offsets","side","reduceOffsets","parentOffsetsCombined","sort","getNegativeOffsetSides","getVisibleLayerSurface","visibleRect","affectedProperty","getVisibleLayerSurfaceWithinScrollParent","surfaces","doesAnchorFitWithinScrollParents","scrollParents","getLayerOffsetsToScrollParentsByAnchor","getOffsetSurface","primarySize","secondarySize","findAnchorByLayerSurface","surface","offsetSurface","square","findBestSuitableAnchor","find","getSecondaryOffsetSide","currentAnchor","firstAnchorThatDoesNotFit","sides","findSecondaryOffset","secondaryAnchorOptions","currentAnchorHasHighestPriority","currentAnchorFits","affectedSide","currentOffsets","secondaryOffset","min","isCenter","includes","getArrowStyle","layerSide","getAbsoluteStyle","autoAdjust","snapToAnchor","possibleAnchorsByPriority","getSuitableAnchor","getSecondaryOffset","layerStyle","ToggleLayer","renderLayer","placement","onStyle","isOpenExternal","closeOnOutsideClick","onOutsideClick","onDisappear","closeOnDisappear","fixed","container","props","triggerRef","relativeParentElement","style","position","process","env","NODE_ENV","containerElement","shouldWarnAboutPositionStyle","console","warn","INITIAL_STYLES","styles","setStyles","lastStyles","isOpenInternal","setOpenInternal","calculateNewLayerStyle","triggerRect","getBoundingClientRect","scrollParentRects","options","preferX","preferY","layerBox","arrowStyle","newStyles","hasOnDisappear","shouldCloseOnDisappear","allScrollParents","partial","full","styleIsSetInterally","effectBecauseOfInternalStyleChange","close","open","toggle","layerProps","willChange","useHover","delayEnter","delayLeave","show","setShow","timeoutRef","timeoutState","onMouseEnter","clearTimeout","setTimeout","onMouseLeave","to"],"mappings":"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"}