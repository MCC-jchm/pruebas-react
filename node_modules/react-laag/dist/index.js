'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var reactDom = require('react-dom');

// created a new dom element and attaches it to the parent element
function useCreateDomElement({
  tag,
  parentElement = document.body
}) {
  const [domElement, setDomElement] = React.useState(null);
  React.useEffect(() => {
    const element = document.createElement(tag);
    parentElement.appendChild(element);
    setDomElement(element);
    return () => {
      parentElement.removeChild(element);
    };
  }, [tag, parentElement]);
  return domElement;
}

function Layer({
  children,
  parentElement = document.body
}) {
  const element = useCreateDomElement({
    tag: "div",
    parentElement
  });

  if (!element) {
    return null;
  }

  return React.createElement(React.Fragment, null, reactDom.createPortal(children, element));
}

function isChildOf(parent, target) {
  if (parent === target) {
    return true;
  }

  const hasChildren = parent.children && parent.children.length > 0;

  if (hasChildren) {
    // tslint:disable-next-line
    for (let i = 0; i < parent.children.length; i++) {
      const child = parent.children[i];

      if (child && isChildOf(child, target)) {
        return true;
      }
    }
  }

  return false;
}

function useOutsideClick(refs, callback) {
  React__default.useEffect(() => {
    function onClick(evt) {
      for (const ref of refs) {
        if (!ref.current) {
          continue;
        }

        if (isChildOf(ref.current, evt.target)) {
          return;
        }
      }

      callback();
    }

    document.addEventListener("click", onClick);
    document.addEventListener("touchstart", onClick);
    return () => {
      document.removeEventListener("click", onClick);
      document.removeEventListener("touchstart", onClick);
    };
  });
}

function useOnScroll(elements, onScroll, trackScroll = true) {
  React.useEffect(() => {
    if (!trackScroll) {
      return;
    }

    const handleScroll = onScroll;
    [...elements, window].forEach(el => {
      el.addEventListener("scroll", handleScroll);
    });
    return () => {
      [...elements, window].forEach(el => {
        el.removeEventListener("scroll", handleScroll);
      });
    };
  }, [onScroll, elements, trackScroll]);
}

/**
 * Tracks an element and keeps it in state
 * (together with other relevant state that depends on the element)
 */

function useElementRef(initialState, elementToState) {
  const [state, setState] = React.useState(initialState || null);
  const lastElement = React.useRef(null);
  const setRef = React.useCallback(node => {
    if (node && node !== lastElement.current) {
      lastElement.current = node;

      if (elementToState) {
        setState(elementToState(node));
      } else {
        setState(node);
      }
    }
  }, []);
  return [setRef, state];
}

function useOnWindowResize(onResize, trackResize = true) {
  React.useEffect(() => {
    if (!trackResize) {
      return;
    }

    const handleResize = onResize;
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [onResize, trackResize]);
}

function safeWindow(getter, fallback) {
  if (typeof window === "undefined") {
    return fallback;
  }

  return getter(window);
}

const useIsomorphicLayoutEffect = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;

function useTrackElementResize(injectedResizeObserver, layerRef, triggerElement, isOpen, callback) {
  const callbackRef = React.useRef(callback);
  callbackRef.current = callback;
  const ResizeObserver = injectedResizeObserver || safeWindow(window => window.ResizeObserver, class ResizeObserver {});

  if (!ResizeObserver) {
    throw new Error("This browser does not support `ResizeObserver` out of the box. Please provide a polyfill as a prop.");
  }

  const resizeObserver = React.useRef(new ResizeObserver(() => {
    if (layerRef.current) {
      callbackRef.current();
    }
  }));
  useIsomorphicLayoutEffect(() => {
    if (isOpen) {
      if (triggerElement) {
        resizeObserver.current.observe(triggerElement);
      }
    } else {
      if (triggerElement) {
        resizeObserver.current.unobserve(triggerElement);
      }

      if (layerRef.current) {
        resizeObserver.current.unobserve(layerRef.current);
      }
    }
  }, [isOpen, triggerElement]);
  React.useEffect(() => {
    return () => {
      resizeObserver.current.disconnect();
    };
  }, []);
  return resizeObserver.current;
}

function compensateScrollbars(rect, clientWidth, clientHeight) {
  const scrollbarWidth = rect.width - clientWidth;
  const scrollbarHeight = rect.height - clientHeight;
  return {
    left: rect.left,
    top: rect.top,
    width: rect.width - scrollbarWidth,
    right: rect.right - scrollbarWidth,
    height: rect.height - scrollbarHeight,
    bottom: rect.bottom - scrollbarHeight
  };
}

function findScrollContainers(element) {
  const result = [];
  /* istanbul ignore if */

  if (!element.parentElement) {
    return result;
  }

  if (element === document.body) {
    return result;
  }

  const parent = element.parentElement;
  const {
    overflow,
    overflowX,
    overflowY
  } = window.getComputedStyle(parent);

  if ([overflow, overflowX, overflowY].some(prop => prop === "auto" || prop === "scroll")) {
    result.push(parent);
  }

  return [...result, ...findScrollContainers(parent)];
}

const EMPTY_STYLE = {};
function isSet(value) {
  return value !== undefined && value !== null;
}

function areStylesTheSame(a, b) {
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  for (let i = 0; i < Math.max(aKeys.length, bKeys.length); i++) {
    const key = aKeys[i] || bKeys[i];

    if (a[key] !== b[key]) {
      return false;
    }
  }

  return true;
}

function shouldUpdateStyles(prev, next) {
  if (areStylesTheSame(prev.layer, next.layer) && areStylesTheSame(prev.arrow, next.arrow)) {
    return false;
  }

  return true;
}
function getWindowClientRect() {
  return {
    top: 0,
    left: 0,
    right: window.innerWidth,
    bottom: window.innerHeight,
    height: window.innerHeight,
    width: window.innerWidth
  };
}

const convertFloat = value => parseFloat(value.replace("px", ""));

function getContentBox(element) {
  const {
    width,
    height,
    boxSizing,
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom
  } = window.getComputedStyle(element);
  return {
    width: boxSizing === "border-box" ? convertFloat(width) : [width, borderLeft, borderRight, paddingLeft, paddingRight].reduce((total, value) => total + (value ? convertFloat(value) : 0), 0),
    height: boxSizing === "border-box" ? convertFloat(height) : [height, borderTop, borderBottom, paddingTop, paddingBottom].reduce((total, value) => total + (value ? convertFloat(value) : 0), 0)
  };
}

const Anchor = {
  BOTTOM_LEFT: "BOTTOM_LEFT",
  BOTTOM_RIGHT: "BOTTOM_RIGHT",
  BOTTOM_CENTER: "BOTTOM_CENTER",
  TOP_LEFT: "TOP_LEFT",
  TOP_CENTER: "TOP_CENTER",
  TOP_RIGHT: "TOP_RIGHT",
  LEFT_BOTTOM: "LEFT_BOTTOM",
  LEFT_CENTER: "LEFT_CENTER",
  LEFT_TOP: "LEFT_TOP",
  RIGHT_BOTTOM: "RIGHT_BOTTOM",
  RIGHT_CENTER: "RIGHT_CENTER",
  RIGHT_TOP: "RIGHT_TOP"
};
const POSSIBLE_ANCHORS = Object.keys(Anchor);
function getPrimaryDirection(anchor) {
  return anchor.startsWith("TOP_") || anchor.startsWith("BOTTOM_") ? "Y" : "X";
}

function primaryIsY(primary) {
  return primary === "TOP" || primary === "BOTTOM";
}

function getPrimaryByIndex(index, preferedPrimary, preferedX, preferedY) {
  const prefferedIsY = primaryIsY(preferedPrimary);

  if (index < 3) {
    return preferedPrimary;
  }

  if (index < 6) {
    return prefferedIsY ? preferedX : preferedY;
  }

  if (index < 9) {
    if (prefferedIsY) {
      return ["LEFT", "RIGHT"].filter(x => x !== preferedX)[0];
    } else {
      return ["TOP", "BOTTOM"].filter(x => x !== preferedY)[0];
    }
  }

  if (prefferedIsY) {
    return ["TOP", "BOTTOM"].filter(x => x !== preferedPrimary)[0];
  } else {
    return ["LEFT", "RIGHT"].filter(x => x !== preferedPrimary)[0];
  }
}

function getSecondaryByIndex(index, preferedPrimary, preferedSecondary) {
  const prefferedIsY = primaryIsY(preferedPrimary);

  switch (index) {
    case 9:
    case 0:
      return preferedSecondary;

    case 1:
    case 10:
      {
        if (preferedSecondary === "CENTER") {
          return prefferedIsY ? "RIGHT" : "BOTTOM";
        }

        return "CENTER";
      }

    case 4:
    case 7:
      return "CENTER";

    case 2:
    case 11:
      {
        if (prefferedIsY) {
          return ["LEFT", "RIGHT"].filter(x => x !== preferedSecondary)[0];
        } else {
          return ["TOP", "BOTTOM"].filter(x => x !== preferedSecondary)[0];
        }
      }

    case 3:
    case 6:
      {
        if (prefferedIsY) {
          return preferedPrimary === "BOTTOM" ? "TOP" : "BOTTOM";
        }

        return preferedPrimary === "LEFT" ? "RIGHT" : "LEFT";
      }

    case 5:
    case 8:
      {
        if (prefferedIsY) {
          return preferedPrimary === "BOTTOM" ? "BOTTOM" : "TOP";
        }

        return preferedPrimary === "LEFT" ? "LEFT" : "RIGHT";
      }
  }
  /* istanbul ignore next */


  return "LEFT";
}

function getSecondaryAnchorOptionsByPrimary(primary, anchorOptions) {
  return anchorOptions.filter(anchor => anchor.startsWith(primary));
}
function splitAnchor(anchor) {
  const [primary, secondary] = anchor.split("_");
  return {
    primary,
    secondary
  };
}
function getLayerSideByAnchor(anchor) {
  if (anchor === "CENTER") {
    return "center";
  }

  return splitAnchor(anchor).primary.toLowerCase();
}
function getAnchorPriority(preferedAnchor, possibleAnchors, preferedX, preferedY) {
  const {
    primary,
    secondary
  } = preferedAnchor !== "CENTER" ? splitAnchor(preferedAnchor) : {
    primary: preferedY,
    secondary: "CENTER"
  };
  let anchors = POSSIBLE_ANCHORS.map((_, index) => {
    return `${getPrimaryByIndex(index, primary, preferedX, preferedY)}_${getSecondaryByIndex(index, primary, secondary)}`;
  }).filter(anchor => possibleAnchors.indexOf(anchor) > -1); // include prefered anchor if not included in possibleAnchors

  if (anchors.indexOf(preferedAnchor) === -1) {
    /* istanbul ignore next */
    anchors = [preferedAnchor, ...anchors];
  }

  return anchors;
}

const primaryStyleGetters = {
  BOTTOM: ({
    rects,
    scrollTop,
    triggerOffset
  }) => {
    const {
      trigger,
      relativeParent
    } = rects;
    return {
      top: trigger.top + trigger.height - (relativeParent.top - scrollTop) + triggerOffset
    };
  },
  TOP: ({
    rects,
    scrollTop,
    triggerOffset
  }) => {
    const {
      trigger,
      relativeParent,
      layer
    } = rects;
    return {
      top: trigger.top - layer.height - (relativeParent.top - scrollTop) - triggerOffset
    };
  },
  LEFT: ({
    rects,
    scrollLeft,
    triggerOffset
  }) => {
    const {
      trigger,
      relativeParent,
      layer
    } = rects;
    return {
      left: trigger.left - layer.width - (relativeParent.left - scrollLeft) - triggerOffset
    };
  },
  RIGHT: ({
    rects,
    scrollLeft,
    triggerOffset
  }) => {
    const {
      trigger,
      relativeParent
    } = rects;
    return {
      left: trigger.left - relativeParent.left + scrollLeft + trigger.width + triggerOffset
    };
  }
};
const secondaryStyleGetters = {
  TOP: ({
    rects,
    scrollTop,
    offsetSecondary
  }) => {
    const {
      trigger,
      relativeParent
    } = rects;
    return {
      top: trigger.top - relativeParent.top + scrollTop + offsetSecondary
    };
  },
  BOTTOM: ({
    rects,
    scrollTop,
    offsetSecondary
  }) => {
    const {
      trigger,
      relativeParent,
      layer
    } = rects;
    return {
      top: trigger.bottom - layer.height - (relativeParent.top - scrollTop) - offsetSecondary
    };
  },
  CENTER: ({
    rects,
    scrollTop,
    scrollLeft,
    primaryDirection,
    offsetSecondary
  }) => {
    const {
      trigger,
      relativeParent,
      layer
    } = rects;

    if (primaryDirection === "Y") {
      return {
        left: trigger.left - relativeParent.left + scrollLeft + trigger.width / 2 - layer.width / 2 - offsetSecondary
      };
    }

    return {
      top: trigger.top - relativeParent.top + scrollTop + trigger.height / 2 - layer.height / 2 + offsetSecondary
    };
  },
  LEFT: ({
    rects,
    scrollLeft,
    offsetSecondary
  }) => {
    const {
      trigger,
      relativeParent
    } = rects;
    return {
      left: trigger.left - relativeParent.left + scrollLeft + offsetSecondary
    };
  },
  RIGHT: ({
    rects,
    scrollLeft,
    offsetSecondary
  }) => {
    const {
      trigger,
      relativeParent,
      layer
    } = rects;
    return {
      left: trigger.right - layer.width - (relativeParent.left - scrollLeft) - offsetSecondary
    };
  }
};

const centerGetter = ({
  rects,
  scrollTop,
  scrollLeft
}) => {
  const {
    trigger,
    relativeParent,
    layer
  } = rects;
  const left = trigger.left - relativeParent.left + scrollLeft + trigger.width / 2 - layer.width / 2;
  const top = trigger.top - relativeParent.top + scrollTop + trigger.height / 2 - layer.height / 2;
  return {
    top,
    left
  };
};

function getAbsolutePositions({
  anchor,
  rects,
  triggerOffset,
  offsetSecondary,
  scrollLeft,
  scrollTop
}) {
  if (anchor === "CENTER") {
    return centerGetter({
      rects,
      triggerOffset,
      offsetSecondary,
      scrollLeft,
      scrollTop,
      primaryDirection: "Y"
    });
  }

  const {
    primary,
    secondary
  } = splitAnchor(anchor);
  const primaryDirection = getPrimaryDirection(anchor);
  const primaryStyle = primaryStyleGetters[primary]({
    rects,
    triggerOffset,
    offsetSecondary,
    scrollLeft,
    scrollTop,
    primaryDirection
  });
  const secondaryStyle = secondaryStyleGetters[secondary]({
    rects,
    triggerOffset,
    offsetSecondary,
    scrollLeft,
    scrollTop,
    primaryDirection
  });
  return { ...primaryStyle,
    ...secondaryStyle
  };
}

// anticipate the width / height based on the current anchor

function fixLayerDimensions(originalLayer, anchor, layerDimensions) {
  const dimensions = typeof layerDimensions === "function" ? layerDimensions(getLayerSideByAnchor(anchor)) : layerDimensions;
  return {
    top: originalLayer.top,
    left: originalLayer.left,
    right: originalLayer.right,
    bottom: originalLayer.bottom,
    width: dimensions.width,
    height: dimensions.height
  };
}

const primaryLayerRectGetters = {
  TOP: ({
    trigger,
    layer,
    triggerOffset
  }) => {
    const bottom = trigger.top - triggerOffset;
    return {
      bottom,
      top: bottom - layer.height
    };
  },
  BOTTOM: ({
    trigger,
    layer,
    triggerOffset
  }) => {
    const top = trigger.bottom + triggerOffset;
    return {
      top,
      bottom: top + layer.height
    };
  },
  LEFT: ({
    trigger,
    layer,
    triggerOffset
  }) => {
    const right = trigger.left - triggerOffset;
    return {
      right,
      left: right - layer.width
    };
  },
  RIGHT: ({
    trigger,
    layer,
    triggerOffset
  }) => {
    const left = trigger.right + triggerOffset;
    return {
      left,
      right: left + layer.width
    };
  }
};
const secondaryLayerRectGetters = {
  TOP: ({
    trigger,
    layer,
    offsetSecondary
  }) => {
    const top = trigger.top + offsetSecondary;
    return {
      top,
      bottom: top + layer.height
    };
  },
  BOTTOM: ({
    trigger,
    layer,
    offsetSecondary
  }) => {
    const bottom = trigger.bottom - offsetSecondary;
    return {
      bottom,
      top: bottom - layer.height
    };
  },
  LEFT: ({
    trigger,
    layer,
    offsetSecondary
  }) => {
    const left = trigger.left + offsetSecondary;
    return {
      left,
      right: left + layer.width
    };
  },
  RIGHT: ({
    trigger,
    layer,
    offsetSecondary
  }) => {
    const right = trigger.right - offsetSecondary;
    return {
      right,
      left: right - layer.width
    };
  },
  CENTER: ({
    trigger,
    layer,
    primaryDirection,
    offsetSecondary
  }) => {
    if (primaryDirection === "Y") {
      const left = trigger.left + trigger.width / 2 - layer.width / 2 - offsetSecondary;
      return {
        left,
        right: left + layer.width
      };
    }

    const top = trigger.top + trigger.height / 2 - layer.height / 2 + offsetSecondary;
    return {
      top,
      bottom: top + layer.height
    };
  }
};
function getLayerRectByAnchor({
  trigger,
  layer,
  anchor,
  triggerOffset,
  scrollOffset = 0,
  offsetSecondary = 0,
  layerDimensions
}) {
  let primaryRect;
  let secondaryRect;
  const layerRect = layerDimensions ? fixLayerDimensions(layer, anchor, layerDimensions) : layer;

  if (anchor === "CENTER") {
    primaryRect = secondaryLayerRectGetters.CENTER({
      trigger,
      layer: layerRect,
      primaryDirection: "Y",
      triggerOffset,
      offsetSecondary
    });
    secondaryRect = secondaryLayerRectGetters.CENTER({
      trigger,
      layer: layerRect,
      primaryDirection: "X",
      triggerOffset,
      offsetSecondary
    });
  } else {
    const {
      primary,
      secondary
    } = splitAnchor(anchor);
    const primaryDirection = getPrimaryDirection(anchor);
    primaryRect = primaryLayerRectGetters[primary]({
      trigger,
      layer: layerRect,
      primaryDirection,
      triggerOffset,
      offsetSecondary
    });
    secondaryRect = secondaryLayerRectGetters[secondary]({
      trigger,
      layer: layerRect,
      primaryDirection,
      triggerOffset,
      offsetSecondary
    });
  }

  const result = { ...layer,
    ...primaryRect,
    ...secondaryRect,
    width: layerRect.width,
    height: layerRect.height
  };
  result.top = result.top - scrollOffset;
  result.right = result.right + scrollOffset;
  result.left = result.left - scrollOffset;
  result.bottom = result.bottom + scrollOffset;
  return result;
}

const ALL_OFFSET_SIDES = ["bottom", "top", "left", "right"];

function getLayerOffsetsToParent(layer, parent) {
  return {
    top: layer.top - parent.top,
    bottom: parent.bottom - layer.bottom,
    left: layer.left - parent.left,
    right: parent.right - layer.right
  };
}

function getLayerOffsetsToParents(layer, parents) {
  return parents.map(parent => getLayerOffsetsToParent(layer, parent));
}

function isLayerCompletelyInvisible(layer, parents) {
  return parents.some(parent => {
    return layer.bottom <= parent.top || layer.right <= parent.left || layer.top >= parent.bottom || layer.left >= parent.right;
  });
}
function doesEntireLayerFitWithinScrollParents(layer, parents) {
  const parentOffsets = getLayerOffsetsToParents(layer, parents);
  return parentOffsets.every(offsets => {
    return ALL_OFFSET_SIDES.every(side => offsets[side] >= 0);
  });
}
function reduceOffsets(parentOffsets) {
  const parentOffsetsCombined = parentOffsets.reduce((result, offsets) => {
    ALL_OFFSET_SIDES.forEach(side => {
      result[side] = [...result[side], offsets[side]];
    });
    return result;
  }, {
    top: [],
    bottom: [],
    left: [],
    right: []
  });
  return ALL_OFFSET_SIDES.reduce((result, side) => {
    result[side] = parentOffsetsCombined[side].sort((a, b) => a - b)[0];
    return result;
  }, {});
}
function getNegativeOffsetSides(parentOffsets) {
  const offsets = reduceOffsets(parentOffsets);
  return ALL_OFFSET_SIDES.filter(side => offsets[side] < 0);
}

function getVisibleLayerSurface(layer, parent) {
  const offsets = getLayerOffsetsToParent(layer, parent);
  const visibleRect = ALL_OFFSET_SIDES.filter(side => offsets[side] < 0).reduce((rect, side) => {
    const affectedProperty = side === "top" || side === "bottom" ? "height" : "width";
    return { ...rect,
      [affectedProperty]: rect[affectedProperty] + offsets[side]
    };
  }, layer);
  return visibleRect.width * visibleRect.height;
}

function getVisibleLayerSurfaceWithinScrollParent(layer, parents) {
  const surfaces = parents.map(parent => getVisibleLayerSurface(layer, parent)); // pick smallest

  return surfaces.sort((a, b) => a - b)[0];
}
function doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, layerDimensions) {
  const layerRect = getLayerRectByAnchor({
    anchor,
    trigger: rects.trigger,
    layer: rects.layer,
    triggerOffset,
    scrollOffset,
    layerDimensions
  });
  return doesEntireLayerFitWithinScrollParents(layerRect, rects.scrollParents);
}
function getLayerOffsetsToScrollParentsByAnchor(anchor, rects, triggerOffset, scrollOffset) {
  return getLayerOffsetsToParents(getLayerRectByAnchor({
    anchor,
    trigger: rects.trigger,
    layer: rects.layer,
    triggerOffset,
    scrollOffset
  }), rects.scrollParents);
} // export function getLayerSide(
//   layer: ClientRect,
//   trigger: ClientRect
// ): LayerSide {
//   if (layer.top >= trigger.bottom) {
//     return "bottom";
//   }
//   if (layer.left >= trigger.right) {
//     return "right";
//   }
//   if (layer.bottom <= trigger.top) {
//     return "top";
//   }
//   return "left";
// }

function getOffsetSurface(anchor, layer, triggerOffset, scrollOffset) {
  const primaryDirection = getPrimaryDirection(anchor);
  const primarySize = layer[primaryDirection === "X" ? "width" : "height"] - triggerOffset - scrollOffset * 2;
  const secondarySize = layer[primaryDirection === "X" ? "height" : "width"] - triggerOffset - scrollOffset * 2;
  return primarySize * secondarySize;
}

function findAnchorByLayerSurface(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions) {
  const result = anchorOptions.map(anchor => {
    // get layerRect based on all offsets
    const layerRect = getLayerRectByAnchor({
      anchor,
      layer: rects.layer,
      trigger: rects.trigger,
      scrollOffset,
      triggerOffset,
      layerDimensions
    }); // get smallest visible layer surface for current anchor

    const surface = getVisibleLayerSurfaceWithinScrollParent(layerRect, rects.scrollParents); // get surface of the offsets
    // offsets are important for collision detection, but
    // eventually we are interested in the 'meat' of the layer

    const offsetSurface = getOffsetSurface(anchor, layerRect, triggerOffset, scrollOffset);
    return {
      anchor,
      square: surface - offsetSurface
    };
  }) // sort -> biggest surface first
  .sort((a, b) => b.square - a.square);
  return result[0].anchor;
}

function findBestSuitableAnchor(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions) {
  // STRATEGY A
  // find first that fits parent
  const anchor = anchorOptions.find(anchor => doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset, layerDimensions));

  if (anchor) {
    return anchor;
  } // STRATEGY B
  // find first with biggest surface


  return findAnchorByLayerSurface(rects, anchorOptions, triggerOffset, scrollOffset, layerDimensions);
}

function getSecondaryOffsetSide(currentAnchor, firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset) {
  const primaryDirection = getPrimaryDirection(currentAnchor);
  const offsets = getLayerOffsetsToScrollParentsByAnchor(firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset);
  const sides = getNegativeOffsetSides(offsets);
  return sides.find(side => {
    if (primaryDirection === "X") {
      return side === "top" || side === "bottom";
    }

    return side === "left" || side === "right";
  });
}

function findSecondaryOffset(anchor, anchorOptions, rects, triggerOffset, scrollOffset) {
  const {
    primary
  } = splitAnchor(anchor);
  /**
   * A.
   * Check wether there are other anchors available
   * If not, skip secondary offset
   */

  const secondaryAnchorOptions = getSecondaryAnchorOptionsByPrimary(primary, anchorOptions);

  if (secondaryAnchorOptions.length === 1) {
    return 0;
  }
  /**
   * B.
   * Check whether current anchor is the preffered anchor and whether
   * it fits
   * If so, skip secondary offset
   */


  const currentAnchorHasHighestPriority = secondaryAnchorOptions.indexOf(anchor) === 0;
  const currentAnchorFits = doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset);

  if (currentAnchorHasHighestPriority && currentAnchorFits) {
    return 0;
  }
  /**
   * C.
   * Retrieve the first anchor on same primary side (by priority) that
   * does not fit.
   * Check if there's a relevant side that has a negative offset.
   * If not, skip secondary offset
   */


  const firstAnchorThatDoesNotFit = secondaryAnchorOptions.find(anchor => {
    return !doesAnchorFitWithinScrollParents(anchor, rects, triggerOffset, scrollOffset);
  });
  const affectedSide = getSecondaryOffsetSide(anchor, firstAnchorThatDoesNotFit, rects, triggerOffset, scrollOffset);

  if (!affectedSide) {
    return 0;
  }
  /**
   * Determine the final secondary offset
   */


  const currentOffsets = reduceOffsets(getLayerOffsetsToScrollParentsByAnchor(anchor, rects, triggerOffset, scrollOffset)); // ensure `secondaryOffset` is always negative or 0

  let secondaryOffset = Math.min(-currentOffsets[affectedSide], 0); // when current anchor is center, make `secondaryOffset` positive
  // when affectedSide is bottom or right

  const isCenter = anchor.includes("_CENTER");

  if (isCenter && (affectedSide === "bottom" || affectedSide === "left")) {
    secondaryOffset = -secondaryOffset;
  }

  return secondaryOffset;
}

function getArrowStyle(layer, trigger, layerSide) {
  if (layerSide === "bottom") {
    return {
      bottom: "100%",
      top: null,
      left: trigger.left + trigger.width / 2 - layer.left,
      right: null
    };
  }

  if (layerSide === "right") {
    return {
      right: "100%",
      left: null,
      top: trigger.top + trigger.height / 2 - layer.top,
      bottom: null
    };
  }

  if (layerSide === "top") {
    return {
      top: "100%",
      bottom: null,
      left: trigger.left + trigger.width / 2 - layer.left,
      right: null
    };
  }

  return {
    left: "100%",
    right: null,
    top: trigger.top + trigger.height / 2 - layer.top,
    bottom: null
  };
}

function getAbsoluteStyle({
  rects,
  scrollTop,
  scrollLeft,
  triggerOffset,
  scrollOffset,
  possibleAnchors,
  preferedAnchor,
  preferedX,
  preferedY,
  autoAdjust,
  snapToAnchor,
  layerDimensions
}) {
  // get a list of possible anchors bases on user set props
  const possibleAnchorsByPriority = getAnchorPriority(preferedAnchor, possibleAnchors, preferedX, preferedY); // on `autoAdjust` find best suitable anchor based on
  // window's / scrollParent's position

  const anchor = autoAdjust ? findBestSuitableAnchor(rects, possibleAnchorsByPriority, triggerOffset, scrollOffset, layerDimensions) : preferedAnchor; // calculate a secondary offset when `autoAdjust` is set
  // and `snapToAnchor` is not.
  // Basically it creates a visual effect where it seems that
  // the layer has glued to it's parents sides
  // Note: `offsetSecondary` is disabled when anchor is CENTER

  const offsetSecondary = autoAdjust && !snapToAnchor && anchor !== "CENTER" ? findSecondaryOffset(anchor, possibleAnchorsByPriority, rects, triggerOffset, scrollOffset) : 0;
  const layerStyle = getAbsolutePositions({
    anchor,
    rects,
    triggerOffset,
    offsetSecondary,
    scrollLeft,
    scrollTop
  });
  const layerRect = getLayerRectByAnchor({
    anchor,
    trigger: rects.trigger,
    layer: rects.layer,
    triggerOffset,
    offsetSecondary,
    layerDimensions
  });

  if (layerDimensions) {
    layerStyle.width = layerRect.width;
    layerStyle.height = layerRect.height;
  }

  return {
    layerStyle,
    layerRect,
    anchor
  };
}

function ToggleLayer({
  children,
  renderLayer,
  placement,
  onStyle,
  isOpen: isOpenExternal,
  closeOnOutsideClick,
  onOutsideClick,
  onDisappear,
  closeOnDisappear,
  fixed,
  container,
  ...props
}) {
  /**
   * Tracks trigger element and keeps it in state together with it's
   * relative/absolute positioned parent
   */
  const [triggerRef, {
    relativeParentElement,
    triggerElement,
    scrollParents
  }] = useElementRef({
    triggerElement: null,
    relativeParentElement: null,
    scrollParents: []
  }, React.useCallback(triggerElement => {
    const scrollParents = findScrollContainers(triggerElement);
    const relativeParentElement = scrollParents[0] || document.body;

    if (relativeParentElement === document.body) {
      document.body.style.position = "relative";
    } else if (process.env.NODE_ENV === "development") {
      // Check if we should warn the user about 'position: relative; stuff...'
      const containerElement = typeof container === "function" ? container() : container;
      const position = window.getComputedStyle(relativeParentElement).position;
      const shouldWarnAboutPositionStyle = position !== "relative" && position !== "absolute" && position !== "fixed" && !fixed && !containerElement;

      if (shouldWarnAboutPositionStyle) {
        console.warn(`react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'fixed' prop to true. This is needed in order to position the layers properly. Currently the scroll-container is positioned: "${position}". Visit https://react-laag.com/docs/#position-relative for more info.`, relativeParentElement);
      }
    }

    return {
      triggerElement,
      relativeParentElement,
      scrollParents
    };
  }, []));
  const [INITIAL_STYLES] = React.useState({
    layer: EMPTY_STYLE,
    arrow: EMPTY_STYLE,
    layerSide: placement.anchor.split("_")[0].toLowerCase()
  });
  const [styles, setStyles] = React.useState(INITIAL_STYLES);
  const lastStyles = React.useRef(styles);
  const layerRef = React.useRef(null);
  const [isOpenInternal, setOpenInternal] = React.useState(false);
  const isOpen = isSet(isOpenExternal) ? isOpenExternal : isOpenInternal;
  const calculateNewLayerStyle = React.useCallback(() => {
    /**
     * A.
     * Calculate new layer positions
     */
    const triggerRect = triggerElement.getBoundingClientRect(); // sometimes ResizeObserver calls this function when all values in the
    // trigger ClientRect are 0. Return early in that case

    if (triggerRect.height === 0) {
      return;
    }

    if (!layerRef.current) {
      return;
    } // gather all scroll parents (including the window ClientRect)
    // in order to check for collisions


    const scrollParentRects = fixed ? [getWindowClientRect()] : [...scrollParents.map(parent => compensateScrollbars(parent.getBoundingClientRect(), parent.clientWidth, parent.clientHeight)), getWindowClientRect()];
    const options = {
      autoAdjust: placement.autoAdjust || false,
      snapToAnchor: placement.snapToAnchor || false,
      triggerOffset: placement.triggerOffset || 0,
      scrollOffset: placement.scrollOffset || 0,
      possibleAnchors: placement.possibleAnchors || POSSIBLE_ANCHORS,
      preferedAnchor: placement.anchor,
      preferedX: placement.preferX || "RIGHT",
      preferedY: placement.preferY || "BOTTOM",
      scrollLeft: relativeParentElement === document.body ? 0 : relativeParentElement.scrollLeft,
      scrollTop: relativeParentElement === document.body ? 0 : relativeParentElement.scrollTop,
      relativeParentElement,
      layerDimensions: placement.layerDimensions
    };
    const layerBox = layerRef.current.getBoundingClientRect(); // construct layerRect

    const layer = {
      top: layerBox.top,
      left: layerBox.left,
      right: layerBox.right,
      bottom: layerBox.bottom,
      // use `window.getComputedProperty` for width / height in order
      // to handle things like scale-transforms
      ...getContentBox(layerRef.current)
    };
    const rects = {
      layer,
      relativeParent: relativeParentElement.getBoundingClientRect(),
      scrollParents: scrollParentRects,
      trigger: triggerRect
    };
    const {
      layerRect,
      layerStyle,
      anchor
    } = getAbsoluteStyle({
      rects,
      ...options
    });

    if (fixed) {
      layerStyle.top = layerRect.top;
      layerStyle.left = layerRect.left;
    } // determine in which side to layer will be relative to
    // the trigger


    const layerSide = getLayerSideByAnchor(anchor); // get optional arrow positions
    // anchor-style is pointless when rendered anchor is CENTER

    const arrowStyle = anchor === "CENTER" ? EMPTY_STYLE : getArrowStyle(layerRect, triggerRect, layerSide);
    const newStyles = {
      layer: layerStyle,
      arrow: arrowStyle,
      layerSide
    }; // only update styles when necessary

    if (shouldUpdateStyles(lastStyles.current, newStyles)) {
      // is parent in control of styles? (onStyle)
      if (isSet(onStyle)) {
        lastStyles.current = newStyles;
        onStyle(newStyles.layer, newStyles.arrow, layerSide);
      } // ... otherwise set styles internally
      else {
          setStyles(newStyles);
        }
    }
    /**
     * B.
     * Manage disappearance
     */


    const hasOnDisappear = isSet(onDisappear);
    const shouldCloseOnDisappear = closeOnDisappear && !isSet(isOpenExternal); // Should we respond to the layer's partial or full disappearance?
    // (trigger's disappearance when `fixed` props is set)

    if (hasOnDisappear || shouldCloseOnDisappear) {
      const allScrollParents = [...scrollParents.map(parent => parent.getBoundingClientRect()), getWindowClientRect()];
      const partial = !doesEntireLayerFitWithinScrollParents(fixed ? triggerRect : layerRect, allScrollParents);
      const full = isLayerCompletelyInvisible(fixed ? triggerRect : layerRect, allScrollParents); // if parent is interested in diseappearance...

      if (hasOnDisappear) {
        onDisappear(full ? "full" : "partial");
      } // ... else close accordingly
      else {
          if (closeOnDisappear === "partial" && partial) {
            setOpenInternal(false);
          }

          if (closeOnDisappear === "full" && full) {
            setOpenInternal(false);
          }
        }
    }
  }, [relativeParentElement, isOpen, triggerElement, scrollParents, fixed, placement]); // call `calculateNewLayerStyle` when the layer's / trigger's
  // height and / or width changes

  const resizeObserver = useTrackElementResize(props.ResizeObserver, layerRef, triggerElement, isOpen, calculateNewLayerStyle); // On every render, check a few things...

  useIsomorphicLayoutEffect(() => {
    /**
     * A.
     * Ignore when render is caused by internal style change
     */
    const styleIsSetInterally = !isSet(onStyle);
    const effectBecauseOfInternalStyleChange = styles !== lastStyles.current;

    if (effectBecauseOfInternalStyleChange && styleIsSetInterally) {
      lastStyles.current = styles;
      return;
    } // reset lastStyles-ref when closed


    if (!isOpen) {
      lastStyles.current = INITIAL_STYLES;
      return;
    }
    /**
     * B.
     * Prepare to calculate new layer style
     */
    // if (!triggerElement) {
    //   throw new Error("Please provide a valid ref to the trigger element");
    // } else if (!layerRef.current) {
    //   throw new Error("Please provide a valid ref to the layer element");
    // }


    calculateNewLayerStyle();
  }); // calculate new layer style when window size changes

  useOnWindowResize(calculateNewLayerStyle, isOpen); // calculate new layer style when user scrolls

  useOnScroll(scrollParents, calculateNewLayerStyle, isOpen); // handle clicks that are not originated from the trigger / layer
  // element

  useOutsideClick([{
    current: triggerElement
  }, layerRef], React.useCallback(() => {
    if (!isOpen) {
      return;
    }

    if (onOutsideClick) {
      onOutsideClick();
    }

    if (closeOnOutsideClick && !isSet(isOpenExternal)) {
      setOpenInternal(false);
    }
  }, [isOpen, setOpenInternal, isOpenExternal]));
  const containerElement = typeof container === "function" ? container() : container;
  return React.createElement(React.Fragment, null, React.createElement(React.Fragment, null, children({
    isOpen,
    close: () => {
      /* istanbul ignore next */
      if (isSet(isOpenExternal)) {
        throw new Error("You cannot call `close()` while using the `isOpen` prop");
      }
      /* istanbul ignore next */


      setOpenInternal(false);
    },
    open: () => {
      /* istanbul ignore next */
      if (isSet(isOpenExternal)) {
        throw new Error("You cannot call `open()` while using the `isOpen` prop");
      }
      /* istanbul ignore next */


      setOpenInternal(true);
    },
    toggle: () => {
      /* istanbul ignore next */
      if (isSet(isOpenExternal)) {
        throw new Error("You cannot call `toggle()` while using the `isOpen` prop");
      }

      setOpenInternal(!isOpenInternal);
    },
    triggerRef,
    layerSide: isOpen ? styles.layerSide : null
  }), relativeParentElement && React.createElement(Layer, {
    parentElement: containerElement || relativeParentElement
  }, renderLayer({
    layerProps: {
      ref: element => {
        if (element) {
          // observe the layer for resizing
          // it's ok to observe the same element multiple times
          // since multiple observes of same element are ignored
          resizeObserver.observe(element);
        }

        layerRef.current = element;
      },
      style: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.layer),
        position: fixed ? "fixed" : "absolute",
        willChange: "top, bottom, left, right, width, height"
      }
    },
    arrowStyle: { ...(isSet(onStyle) ? EMPTY_STYLE : styles.arrow),
      position: "absolute",
      willChange: "top, bottom, left, right"
    },
    isOpen,
    layerSide: styles.layerSide,
    triggerRect: triggerElement ? triggerElement.getBoundingClientRect() : null,
    close: () => {
      /* istanbul ignore next */
      if (isSet(isOpenExternal)) {
        throw new Error("You cannot call `close()` while using the `isOpen` prop");
      }
      /* istanbul ignore next */


      setOpenInternal(false);
    }
  }))));
}

function useHover({
  delayEnter = 0,
  delayLeave = 0
}) {
  const [show, setShow] = React.useState(false);
  const timeoutRef = React.useRef(null);
  const timeoutState = React.useRef(null);

  function onMouseEnter() {
    // if was leaving, stop leaving
    if (timeoutState.current === "leaving" && timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
      timeoutState.current = null;
    }

    if (show) {
      return;
    }

    timeoutState.current = "entering";
    timeoutRef.current = setTimeout(() => {
      setShow(true);
      timeoutRef.current = null;
      timeoutState.current = null;
    }, delayEnter);
  }

  function onMouseLeave() {
    // if was waiting for entering,
    // clear timeout
    if (timeoutState.current === "entering" && timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }

    if (!show) {
      return;
    }

    timeoutState.current = "leaving";
    timeoutRef.current = setTimeout(() => {
      setShow(false);
      timeoutRef.current = null;
    }, delayLeave);
  } // make sure to clear timeout on unmount


  React.useEffect(() => {
    const to = timeoutRef.current;

    function onScroll() {
      if (show) {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }

        setShow(false);
      }
    }

    window.addEventListener("scroll", onScroll, true);
    return () => {
      window.removeEventListener("scroll", onScroll);

      if (to) {
        clearTimeout(to);
      }
    };
  }, [show]);
  return [show, {
    onMouseEnter,
    onMouseLeave
  }];
}

exports.ToggleLayer = ToggleLayer;
exports.useHover = useHover;
exports.anchor = Anchor;
//# sourceMappingURL=index.js.map
